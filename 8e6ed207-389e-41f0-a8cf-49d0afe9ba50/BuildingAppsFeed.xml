<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Windows Developer Blog</title>
	<atom:link href="https://blogs.windows.com/buildingapps/feed/" rel="self" type="application/rss+xml" />
	<link>https://blogs.windows.com/buildingapps</link>
	<description></description>
	<lastBuildDate>Thu, 30 Aug 2018 16:00:42 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.8</generator>

<image>
	<url>https://blogs.windows.com/uploads/sites/3/2016/12/cropped-Windows-logo2-70x70.png</url>
	<title>Windows Developer Blog</title>
	<link>https://blogs.windows.com/buildingapps</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>#ifdef WINDOWS – MIDL 3 with Larry Osterman</title>
		<link>https://blogs.windows.com/buildingapps/2018/08/30/ifdef-windows-midl-3-with-larry-osterman/</link>
		<comments>https://blogs.windows.com/buildingapps/2018/08/30/ifdef-windows-midl-3-with-larry-osterman/#respond</comments>
		<pubDate>Thu, 30 Aug 2018 16:00:42 +0000</pubDate>
		<dc:creator><![CDATA[Nikola Metulev]]></dc:creator>
				<category><![CDATA[PC]]></category>
		<category><![CDATA[#ifdef]]></category>
		<category><![CDATA[Microsoft Interface Definition Language]]></category>
		<category><![CDATA[MIDL]]></category>

		<guid isPermaLink="false">http://blogs.windows.com/buildingapps/?p=54084</guid>
		<description><![CDATA[<p>Microsoft Interface Definition Language (MIDL) 3.0 is a simplified, modern syntax for declaring Windows Runtime types inside Interface Definition Language (IDL) files (.idl files). It is a particularly convenient way to declare C++/WinRT runtime classes. In this video, Larry Osterman, lead developer on the COM team in Windows, gave us a deep dive in MIDL and how it all ties in the [&#8230;]</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/30/ifdef-windows-midl-3-with-larry-osterman/">#ifdef WINDOWS – MIDL 3 with Larry Osterman</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p><iframe class='youtube-player' type='text/html' width='640' height='390' src='https://www.youtube-nocookie.com/embed/5tQEHuxb7TM?version=3&#038;rel=1&#038;fs=1&#038;autohide=2&#038;showsearch=0&#038;showinfo=1&#038;iv_load_policy=1&#038;wmode=transparent' allowfullscreen='true' style='border:0;'></iframe></p>
<p>Microsoft Interface Definition Language (MIDL) 3.0 is a simplified, modern syntax for declaring Windows Runtime types inside Interface Definition Language (IDL) files (.idl files). It is a particularly convenient way to declare <a href="https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/index">C++/WinRT</a> runtime classes.</p>
<p>In this video, Larry Osterman, lead developer on the COM team in Windows, gave us a deep dive in MIDL and how it all ties in the Windows Runtime. Larry shared how MIDL started and how it got to where it is today. Watch the full video above and feel free to reach out on <a href="http://twitter.com/ifdefwindows">Twitter </a>or in the comments below for questions or comments.</p>
<p>Happy coding!</p>
<p><em>#ifdef WINDOWS is a periodic dev show by developers for developers focused on Windows development through interviews of engineers working on the Windows platform. Learn why and how features and APIs are built, how to be more successful building Windows apps, what goes into building for Windows and ultimately how to become a better Windows developer. Subscribe to the <a href="https://www.youtube.com/channel/UC5bAdmtv4lG3SZwRnPw6iPQ">YouTube channel</a> for notifications about new videos as they are posted, and make sure to reach out on <a href="https://twitter.com/ifdefwindows">Twitter</a> for comments and suggestions.</em></p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/30/ifdef-windows-midl-3-with-larry-osterman/">#ifdef WINDOWS – MIDL 3 with Larry Osterman</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></content:encoded>
			<wfw:commentRss>https://blogs.windows.com/buildingapps/2018/08/30/ifdef-windows-midl-3-with-larry-osterman/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Windows 10 SDK Preview Build 17744 available now!</title>
		<link>https://blogs.windows.com/buildingapps/2018/08/28/windows-10-sdk-preview-build-17744-available-now/</link>
		<comments>https://blogs.windows.com/buildingapps/2018/08/28/windows-10-sdk-preview-build-17744-available-now/#comments</comments>
		<pubDate>Tue, 28 Aug 2018 17:15:25 +0000</pubDate>
		<dc:creator><![CDATA[Clint Rutkas]]></dc:creator>
				<category><![CDATA[PC]]></category>
		<category><![CDATA[MSIX]]></category>
		<category><![CDATA[SDK]]></category>
		<category><![CDATA[Visual Studio]]></category>
		<category><![CDATA[Windows 10 SDK Preview Build]]></category>

		<guid isPermaLink="false">http://blogs.windows.com/buildingapps/?p=54057</guid>
		<description><![CDATA[<p>Today, we released a new Windows 10 Preview Build of the SDK to be used in conjunction with Windows 10 Insider Preview (Build 17744 or greater). The Preview SDK Build 17744 contains bug fixes and under development changes to the API surface area. The Preview SDK can be downloaded from developer section on Windows Insider. For feedback and [&#8230;]</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/28/windows-10-sdk-preview-build-17744-available-now/">Windows 10 SDK Preview Build 17744 available now!</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p>Today, we released a new Windows 10 Preview Build of the SDK to be used in conjunction with <a href="https://insider.windows.com/en-us/">Windows 10 Insider Preview</a> (Build <strong>17744 </strong>or greater). The Preview SDK Build <strong>17744 </strong>contains bug fixes and under development changes to the API surface area.</p>
<p>The Preview SDK can be downloaded from <a href="https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewSDK">developer section on Windows Insider</a>.</p>
<p>For feedback and updates to the known issues, please see the <a href="https://social.msdn.microsoft.com/Forums/en-US/home?forum=Win10SDKToolsIssues">developer forum.</a> For new developer feature requests, head over to our <a href="https://wpdev.uservoice.com/">Windows Platform UserVoice.</a></p>
<h1><strong>Things to note:</strong></h1>
<ul>
<li>This build works in conjunction with previously released SDKs and Visual Studio 2017. You can install this SDK and still also continue to submit your apps that target Windows 10 build 1803 or earlier to the store.</li>
<li>The Windows SDK will now formally only be supported by Visual Studio 2017 and greater. You can download the Visual Studio 2017 <a href="https://visualstudio.microsoft.com/downloads/">here</a>.</li>
<li>This build of the Windows SDK <strong>will</strong> only install on <a href="https://insider.windows.com/en-us/">Windows 10 Insider Preview</a> builds.</li>
<li>In order to assist with script access to the SDK, the ISO will also be able to be accessed through the following URL: <a href="https://go.microsoft.com/fwlink/?prd=11966&amp;pver=1.0&amp;plcid=0x409&amp;clcid=0x409&amp;ar=Flight&amp;sar=Sdsurl&amp;o1=17744">https://go.microsoft.com/fwlink/?prd=11966&amp;pver=1.0&amp;plcid=0x409&amp;clcid=0x409&amp;ar=Flight&amp;sar=Sdsurl&amp;o1=17744</a> once the static URL is published.</li>
</ul>
<h1><strong>C++/WinRT Update for build 17709 and beyond:</strong></h1>
<p>This update introduces many improvements and fixes for C++/WinRT. Notably, it introduces the ability to build C++/WinRT without any dependency on the Windows SDK. This isn’t particularly interesting to the OS developer, but even in the OS repo it provides benefits because it does not itself include any Windows headers. Thus, a developer will typically pull in fewer or no dependencies inadvertently. This also means a dramatic reduction in the number of macros that a C++/WinRT developer must guard against. Removing the dependency on the Windows headers means that C++/WinRT is more portable and standards compliant and furthers our efforts to make it a cross-compiler and cross-platform library. It also means that the C++/WinRT headers will never be mangled by macros. If you previously relied on C++/WinRT to include various Windows headers that you will now have to include them yourself. It has always been good practice to include any headers you depend on explicitly and not rely on another library to include them for you.</p>
<h2><strong>Highlights</strong></h2>
<p><strong>Support get_strong and get_weak to create delegates:</strong> This update allows a developer to use either get_strong or get_weak instead of a raw this pointer when creating a delegate pointing to a member function.</p>
<p><strong>Add async cancellation callback:</strong> The most frequently requested feature for C++/WinRT&#8217;s coroutine support has been the addition of a cancellation callback.</p>
<p><strong>Simplify the use of APIs expecting IBuffer parameters:</strong> Although most APIs prefer collections or arrays, enough APIs rely on IBuffer that it should be easier to use such APIs from C++. This update provides direct access to the data behind an IBuffer implementation using the same data naming convention used by the C++ standard library containers. This also avoids colliding with metadata names that conventionally begin with an uppercase letter.</p>
<p><strong>Conformance:</strong> Improved support for Clang and Visual C++’s stricter conformance modes.</p>
<p><strong>Improved code gen:</strong> Various improvements to reduce code size, improve inlining, and optimize factory caching.</p>
<p><strong>Remove unnecessary recursion:</strong> When the command line refers to a folder rather than a specific winmd, cppwinrt will no longer search recursively for winmd files. It causes performance problems in the OS build and can lead to usage errors that are hard to diagnose when developers inadvertently cause cppwinrt to consume more winmds than expected. The cppwinrt compiler also now handles duplicates more intelligently, making it more resilient to user error and poorly-formed winmd files.</p>
<p><strong>Declare both WINRT_CanUnloadNow and WINRT_GetActivationFactory in base.h:</strong> Callers don’t need to declare them directly. Their signatures have also changed, amounting to a breaking change. The declarations alleviate most of the pain of this change. The change is necessitated by the fact that C++/WinRT no longer depends on the Windows headers and this change removes the dependency on the types from the Windows headers.</p>
<p><strong>Harden smart pointers:</strong> The event revokers didn’t revoke when move-assigned a new value. This lead us to take a closer look at the smart pointer classes. We noticed that they were not reliably handling self-assignment. This is rooted in the com_ptr class template that most of the others rely on. We fixed com_ptr and updated the event revokers to handle move semantics correctly to ensure that they revoke upon assignment. The handle class template has also been hardened by the removal of the implicit constructor that made it easy to write incorrect code. This also turned bugs in the OS into compiler errors fixed in this PR.</p>
<h2><strong>Breaking Changes</strong></h2>
<p>Support for non-WinRT interfaces is disabled by default. To enable, simply #include &lt;unknwn.h&gt; before any C++/WinRT headers.</p>
<p>winrt::get_abi(winrt::hstring) now returns void* instead of HSTRING. Code requiring the HSTRING ABI can simply use a static_cast.</p>
<p>winrt::put_abi(winrt::hstring) returns void** instead of HSTRING*. Code requiring the HSTRING ABI can simply use a reinterpret_cast.</p>
<p>HRESULT is now projected as winrt::hresult. Code requiring an HRESULT can simply static_cast if you need to do type checking or support type traits, but it is otherwise convertible as long as &lt;unknwn.h&gt; is included first.</p>
<p>GUID is now projected as winrt::guid. Code implementing APIs with GUID parameters must use winrt::guid instead, but it is otherwise convertible as long as &lt;unknwn.h&gt; is included first.</p>
<p>The signatures of WINRT_CanUnloadNow and WINRT_GetActivationFactory has changed. Code must not declare these functions at all and instead include winrt/base.h to include their declarations.</p>
<p>The winrt::handle constructor is now explicit. Code assigning a raw handle value must call the attach method instead.</p>
<p>winrt::clock::from_FILETIME has been deprecated. Code should use winrt::clock::from_file_time instead.</p>
<h1><strong>What&#8217;s New:</strong></h1>
<h2><strong>MSIX Support</strong></h2>
<p>It’s finally here! You can now package your applications as MSIX. These applications can be installed and run on any device with <strong>17682</strong> build or later.</p>
<p>To package your application with MSIX, use the <a href="https://docs.microsoft.com/en-us/windows/desktop/appxpkg/make-appx-package--makeappx-exe-">MakeAppx tool</a>. To install the application – just click on the MSIX file. To learn more about MSIX, watch this introductory video: <a href="https://channel9.msdn.com/events/Build/2018/BRK2432?term=msix%20inside%20and%20out">link</a></p>
<p>Feedback and comments are welcome on our MSIX community: <a href="http://aka.ms/MSIXCommunity">http://aka.ms/MSIXCommunity</a></p>
<p>MSIX is not currently supported by the App Certification Kit nor the Microsoft Store at this time.</p>
<h2><strong>MC.EXE</strong></h2>
<p>We’ve made some important changes to the C/C++ ETW code generation of mc.exe (Message Compiler):</p>
<p>The “-mof” parameter is deprecated. This parameter instructs MC.exe to generate ETW code that is compatible with Windows XP and earlier. Support for the “-mof” parameter will be removed in a future version of mc.exe.</p>
<p>As long as the “-mof” parameter is not used, the generated C/C++ header is now compatible with both kernel-mode and user-mode, regardless of whether “-km” or “-um” was specified on the command line. The header will use the _ETW_KM_ macro to automatically determine whether it is being compiled for kernel-mode or user-mode and will call the appropriate ETW APIs for each mode.</p>
<ul>
<li>The only remaining difference between “-km” and “-um” is that the EventWrite[EventName] macros generated with “-km” have an Activity ID parameter while the EventWrite[EventName] macros generated with “-um” do not have an Activity ID parameter.</li>
</ul>
<p>The EventWrite[EventName] macros now default to calling EventWriteTransfer (user mode) or EtwWriteTransfer (kernel mode). Previously, the EventWrite[EventName] macros defaulted to calling EventWrite (user mode) or EtwWrite (kernel mode).</p>
<ul>
<li>The generated header now supports several customization macros. For example, you can set the MCGEN_EVENTWRITETRANSFER macro if you need the generated macros to call something other than EventWriteTransfer.</li>
<li>The manifest supports new attributes.</li>
<li>Event “name”: non-localized event name.</li>
<li>Event “attributes”: additional key-value metadata for an event such as filename, line number, component name, function name.</li>
<li>Event “tags”: 28-bit value with user-defined semantics (per-event).</li>
<li>Field “tags”: 28-bit value with user-defined semantics (per-field – can be applied to “data” or “struct” elements).</li>
<li>You can now define “provider traits” in the manifest (e.g. provider group). If provider traits are used in the manifest, the EventRegister[ProviderName] macro will automatically register them.</li>
<li>MC will now report an error if a localized message file is missing a string. (Previously MC would silently generate a corrupt message resource).</li>
<li>MC can now generate Unicode (utf-8 or utf-16) output with the “-cp utf-8” or “-cp utf-16” parameters.</li>
</ul>
<h1><strong>Known Issues:</strong></h1>
<p>The SDK headers are generated with types in the “ABI” namespace. This is done to avoid conflicts with C++/CX and C++/WinRT clients that need to consume types directly at the ABI layer[1]. By default, types emitted by MIDL are *<strong>not</strong>* put in the ABI namespace, however this has the potential to introduce conflicts from teams attempting to consume ABI types from Windows WinRT MIDL generated headers and non-Windows WinRT MIDL generated headers (this is especially challenging if the non-Windows header references Windows types).</p>
<p>To ensure that developers have a consistent view of the WinRT API surface, validation has been added to the generated headers to ensure that the ABI prefix is consistent between the Windows headers and user generated headers. If you encounter an error like:</p>
<p>5&gt;c:\program files (x86)\windows kits\10\include\10.0.17687.0\winrt\windows.foundation.h(83): error C2220: warning treated as error &#8211; no &#8216;object&#8217; file generated</p>
<p>5&gt;c:\program files (x86)\windows kits\10\include\10.0.17687.0\winrt\windows.foundation.h(83): warning C4005: &#8216;CHECK_NS_PREFIX_STATE&#8217;: macro redefinition</p>
<p>5&gt;g:\&lt;PATH TO YOUR HEADER HERE&gt;(41): note: see previous definition of &#8216;CHECK_NS_PREFIX_STATE&#8217;</p>
<p>It means that some of your MIDL generated headers are inconsistent with the system generated headers.</p>
<p><strong>There are two ways to fix this:</strong></p>
<ul>
<li><strong>Preferred:</strong> Compile your IDL file with the /ns_prefix MIDL command line switch. This will cause all your types to be moved to the ABI namespace consistent with the Windows headers. This may require code changes in your code however.</li>
<li><strong>Alternate:</strong> Add #define DISABLE_NS_PREFIX_CHECKS before including the Windows headers. This will suppress the validation.</li>
</ul>
<h2><strong>Windows App Certification Kit Crashes</strong></h2>
<p>The Windows App Certification Kit will crash when running. To avoid this failure we recommend not installing the Windows App Certification Kit. You can uncheck this option during setup.</p>
<h1><strong>API Updates, Additions and Removals</strong></h1>
<p>When targeting new APIs, consider writing your app to be adaptive in order to run correctly on the widest number of Windows 10 devices. Please see <a href="https://blogs.windows.com/buildingapps/2015/09/15/dynamically-detecting-features-with-api-contracts-10-by-10/#HdHAk5RVtCg6bW4O.97">Dynamically detecting features with API contracts (10 by 10)</a> for more information.</p>
<p>The following APIs have been added to the platform since the release of 17134. The APIs listed below have been removed.</p>
<p>There have been no changes to this API surface since build 17738.</p>
<h2>Additions:</h2>
<pre class="brush: csharp; title: ; notranslate">

namespace Windows.AI.MachineLearning {
  public interface ILearningModelFeatureDescriptor
  public interface ILearningModelFeatureValue
  public interface ILearningModelOperatorProvider
  public sealed class ImageFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class ImageFeatureValue : ILearningModelFeatureValue
  public interface ITensor : ILearningModelFeatureValue
  public sealed class LearningModel : IClosable
  public sealed class LearningModelBinding : IIterable&lt;IKeyValuePair&lt;string, object&gt;&gt;, IMapView&lt;string, object&gt;
  public sealed class LearningModelDevice
  public enum LearningModelDeviceKind
  public sealed class LearningModelEvaluationResult
  public enum LearningModelFeatureKind
  public sealed class LearningModelSession : IClosable
  public struct MachineLearningContract
  public sealed class MapFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class SequenceFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class TensorBoolean : ILearningModelFeatureValue, ITensor
  public sealed class TensorDouble : ILearningModelFeatureValue, ITensor
  public sealed class TensorFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class TensorFloat : ILearningModelFeatureValue, ITensor
  public sealed class TensorFloat16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt32Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt64Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt8Bit : ILearningModelFeatureValue, ITensor
  public enum TensorKind
  public sealed class TensorString : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt32Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt64Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt8Bit : ILearningModelFeatureValue, ITensor
}
namespace Windows.ApplicationModel {
  public sealed class AppInstallerInfo
  public sealed class LimitedAccessFeatureRequestResult
  public static class LimitedAccessFeatures
  public enum LimitedAccessFeatureStatus
  public sealed class Package {
    IAsyncOperation&lt;PackageUpdateAvailabilityResult&gt; CheckUpdateAvailabilityAsync();
    AppInstallerInfo GetAppInstallerInfo();
  }
  public enum PackageUpdateAvailability
  public sealed class PackageUpdateAvailabilityResult
}
namespace Windows.ApplicationModel.Calls {
  public sealed class VoipCallCoordinator {
    IAsyncOperation&lt;VoipPhoneCallResourceReservationStatus&gt; ReserveCallResourcesAsync();
  }
}
namespace Windows.ApplicationModel.Chat {
  public static class ChatCapabilitiesManager {
    public static IAsyncOperation&lt;ChatCapabilities&gt; GetCachedCapabilitiesAsync(string address, string transportId);
    public static IAsyncOperation&lt;ChatCapabilities&gt; GetCapabilitiesFromNetworkAsync(string address, string transportId);
  }
  public static class RcsManager {
    public static event EventHandler&lt;object&gt; TransportListChanged;
  }
}
namespace Windows.ApplicationModel.DataTransfer {
  public static class Clipboard {
    public static event EventHandler&lt;ClipboardHistoryChangedEventArgs&gt; HistoryChanged;
    public static event EventHandler&lt;object&gt; HistoryEnabledChanged;
    public static event EventHandler&lt;object&gt; RoamingEnabledChanged;
    public static bool ClearHistory();
    public static bool DeleteItemFromHistory(ClipboardHistoryItem item);
    public static IAsyncOperation&lt;ClipboardHistoryItemsResult&gt; GetHistoryItemsAsync();
    public static bool IsHistoryEnabled();
    public static bool IsRoamingEnabled();
    public static bool SetContentWithOptions(DataPackage content, ClipboardContentOptions options);
    public static SetHistoryItemAsContentStatus SetHistoryItemAsContent(ClipboardHistoryItem item);
  }
  public sealed class ClipboardContentOptions
  public sealed class ClipboardHistoryChangedEventArgs
  public sealed class ClipboardHistoryItem
  public sealed class ClipboardHistoryItemsResult
  public enum ClipboardHistoryItemsResultStatus
  public sealed class DataPackagePropertySetView : IIterable&lt;IKeyValuePair&lt;string, object&gt;&gt;, IMapView&lt;string, object&gt; {
    bool IsFromRoamingClipboard { get; }
    string SourceDisplayName { get; }
  }
  public enum SetHistoryItemAsContentStatus
}
namespace Windows.ApplicationModel.Store.Preview {
  public enum DeliveryOptimizationDownloadMode
  public enum DeliveryOptimizationDownloadModeSource
  public sealed class DeliveryOptimizationSettings
  public static class StoreConfiguration {
    public static bool IsPinToDesktopSupported();
    public static bool IsPinToStartSupported();
    public static bool IsPinToTaskbarSupported();
    public static void PinToDesktop(string appPackageFamilyName);
    public static void PinToDesktopForUser(User user, string appPackageFamilyName);
  }
}
namespace Windows.ApplicationModel.Store.Preview.InstallControl {
  public enum AppInstallationToastNotificationMode
  public sealed class AppInstallItem {
    AppInstallationToastNotificationMode CompletedInstallToastNotificationMode { get; set; }
    AppInstallationToastNotificationMode InstallInProgressToastNotificationMode { get; set; }
    bool PinToDesktopAfterInstall { get; set; }
    bool PinToStartAfterInstall { get; set; }
    bool PinToTaskbarAfterInstall { get; set; }
  }
  public sealed class AppInstallManager {
    bool CanInstallForAllUsers { get; }
  }
  public sealed class AppInstallOptions {
    string CampaignId { get; set; }
    AppInstallationToastNotificationMode CompletedInstallToastNotificationMode { get; set; }
    string ExtendedCampaignId { get; set; }
    bool InstallForAllUsers { get; set; }
    AppInstallationToastNotificationMode InstallInProgressToastNotificationMode { get; set; }
    bool PinToDesktopAfterInstall { get; set; }
    bool PinToStartAfterInstall { get; set; }
    bool PinToTaskbarAfterInstall { get; set; }
    bool StageButDoNotInstall { get; set; }
  }
  public sealed class AppUpdateOptions {
    bool AutomaticallyDownloadAndInstallUpdateIfFound { get; set; }
  }
}
namespace Windows.ApplicationModel.UserActivities {
  public sealed class UserActivity {
    bool IsRoamable { get; set; }
  }
}
namespace Windows.Data.Text {
  public sealed class TextPredictionGenerator {
    CoreTextInputScope InputScope { get; set; }
    IAsyncOperation&lt;IVectorView&lt;string&gt;&gt; GetCandidatesAsync(string input, uint maxCandidates, TextPredictionOptions predictionOptions, IIterable&lt;string&gt; previousStrings);
    IAsyncOperation&lt;IVectorView&lt;string&gt;&gt; GetNextWordCandidatesAsync(uint maxCandidates, IIterable&lt;string&gt; previousStrings);
  }
  public enum TextPredictionOptions : uint
}
namespace Windows.Devices.Display.Core {
  public sealed class DisplayAdapter
  public enum DisplayBitsPerChannel : uint
  public sealed class DisplayDevice
  public enum DisplayDeviceCapability
  public sealed class DisplayFence
  public sealed class DisplayManager : IClosable
  public sealed class DisplayManagerChangedEventArgs
  public sealed class DisplayManagerDisabledEventArgs
  public sealed class DisplayManagerEnabledEventArgs
  public enum DisplayManagerOptions : uint
  public sealed class DisplayManagerPathsFailedOrInvalidatedEventArgs
  public enum DisplayManagerResult
  public sealed class DisplayManagerResultWithState
  public sealed class DisplayModeInfo
  public enum DisplayModeQueryOptions : uint
  public sealed class DisplayPath
  public enum DisplayPathScaling
  public enum DisplayPathStatus
  public struct DisplayPresentationRate
  public sealed class DisplayPrimaryDescription
  public enum DisplayRotation
  public sealed class DisplayScanout
  public sealed class DisplaySource
  public sealed class DisplayState
  public enum DisplayStateApplyOptions : uint
  public enum DisplayStateFunctionalizeOptions : uint
  public sealed class DisplayStateOperationResult
  public enum DisplayStateOperationStatus
  public sealed class DisplaySurface
  public sealed class DisplayTarget
  public enum DisplayTargetPersistence
  public sealed class DisplayTask
  public sealed class DisplayTaskPool
  public enum DisplayTaskSignalKind
  public sealed class DisplayView
  public sealed class DisplayWireFormat
  public enum DisplayWireFormatColorSpace
  public enum DisplayWireFormatEotf
  public enum DisplayWireFormatHdrMetadata
  public enum DisplayWireFormatPixelEncoding
}
namespace Windows.Devices.Enumeration {
  public enum DeviceInformationKind {
    DevicePanel = 8,
  }
  public sealed class DeviceInformationPairing {
    public static bool TryRegisterForAllInboundPairingRequestsWithProtectionLevel(DevicePairingKinds pairingKindsSupported, DevicePairingProtectionLevel minProtectionLevel);
  }
}
namespace Windows.Devices.Enumeration.Pnp {
  public enum PnpObjectType {
    DevicePanel = 8,
  }
}
namespace Windows.Devices.Lights {
  public sealed class LampArray
  public enum LampArrayKind
  public sealed class LampInfo
  public enum LampPurposes : uint
}
namespace Windows.Devices.Lights.Effects {
  public interface ILampArrayEffect
  public sealed class LampArrayBitmapEffect : ILampArrayEffect
  public sealed class LampArrayBitmapRequestedEventArgs
  public sealed class LampArrayBlinkEffect : ILampArrayEffect
  public sealed class LampArrayColorRampEffect : ILampArrayEffect
  public sealed class LampArrayCustomEffect : ILampArrayEffect
  public enum LampArrayEffectCompletionBehavior
  public sealed class LampArrayEffectPlaylist : IIterable&lt;ILampArrayEffect&gt;, IVectorView&lt;ILampArrayEffect&gt;
  public enum LampArrayEffectStartMode
  public enum LampArrayRepetitionMode
  public sealed class LampArraySolidEffect : ILampArrayEffect
  public sealed class LampArrayUpdateRequestedEventArgs
}
namespace Windows.Devices.PointOfService {
  public sealed class BarcodeScannerCapabilities {
    bool IsVideoPreviewSupported { get; }
  }
  public sealed class ClaimedBarcodeScanner : IClosable {
    event TypedEventHandler&lt;ClaimedBarcodeScanner, ClaimedBarcodeScannerClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedBarcodeScannerClosedEventArgs
  public sealed class ClaimedCashDrawer : IClosable {
    event TypedEventHandler&lt;ClaimedCashDrawer, ClaimedCashDrawerClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedCashDrawerClosedEventArgs
  public sealed class ClaimedLineDisplay : IClosable {
    event TypedEventHandler&lt;ClaimedLineDisplay, ClaimedLineDisplayClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedLineDisplayClosedEventArgs
  public sealed class ClaimedMagneticStripeReader : IClosable {
    event TypedEventHandler&lt;ClaimedMagneticStripeReader, ClaimedMagneticStripeReaderClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedMagneticStripeReaderClosedEventArgs
  public sealed class ClaimedPosPrinter : IClosable {
    event TypedEventHandler&lt;ClaimedPosPrinter, ClaimedPosPrinterClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedPosPrinterClosedEventArgs
}
namespace Windows.Devices.PointOfService.Provider {
  public sealed class BarcodeScannerDisableScannerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerEnableScannerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerFrameReader : IClosable
  public sealed class BarcodeScannerFrameReaderFrameArrivedEventArgs
  public sealed class BarcodeScannerGetSymbologyAttributesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerHideVideoPreviewRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerProviderConnection : IClosable {
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync();
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync(BitmapPixelFormat preferredFormat);
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync(BitmapPixelFormat preferredFormat, BitmapSize preferredSize);
  }
  public sealed class BarcodeScannerSetActiveSymbologiesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerSetSymbologyAttributesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerStartSoftwareTriggerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerStopSoftwareTriggerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerVideoFrame : IClosable
}
namespace Windows.Devices.Sensors {
  public sealed class HingeAngleReading
  public sealed class HingeAngleSensor
  public sealed class HingeAngleSensorReadingChangedEventArgs
  public sealed class SimpleOrientationSensor {
    public static IAsyncOperation&lt;SimpleOrientationSensor&gt; FromIdAsync(string deviceId);
    public static string GetDeviceSelector();
  }
}
namespace Windows.Devices.SmartCards {
  public static class KnownSmartCardAppletIds
  public sealed class SmartCardAppletIdGroup {
    string Description { get; set; }
    IRandomAccessStreamReference Logo { get; set; }
    ValueSet Properties { get; }
    bool SecureUserAuthenticationRequired { get; set; }
  }
  public sealed class SmartCardAppletIdGroupRegistration {
    string SmartCardReaderId { get; }
    IAsyncAction SetPropertiesAsync(ValueSet props);
  }
}
namespace Windows.Devices.WiFi {
  public enum WiFiPhyKind {
    HE = 10,
  }
}
namespace Windows.Foundation {
  public static class GuidHelper
}
namespace Windows.Globalization {
  public static class CurrencyIdentifiers {
    public static string MRU { get; }
    public static string SSP { get; }
    public static string STN { get; }
    public static string VES { get; }
  }
}
namespace Windows.Graphics.Capture {
  public sealed class Direct3D11CaptureFramePool : IClosable {
    public static Direct3D11CaptureFramePool CreateFreeThreaded(IDirect3DDevice device, DirectXPixelFormat pixelFormat, int numberOfBuffers, SizeInt32 size);
  }
  public sealed class GraphicsCaptureItem {
    public static GraphicsCaptureItem CreateFromVisual(Visual visual);
  }
}
namespace Windows.Graphics.Display.Core {
  public enum HdmiDisplayHdrOption {
    DolbyVisionLowLatency = 3,
  }
  public sealed class HdmiDisplayMode {
    bool IsDolbyVisionLowLatencySupported { get; }
  }
}
namespace Windows.Graphics.Holographic {
  public sealed class HolographicCamera {
    bool IsHardwareContentProtectionEnabled { get; set; }
    bool IsHardwareContentProtectionSupported { get; }
  }
  public sealed class HolographicQuadLayerUpdateParameters {
    bool CanAcquireWithHardwareProtection { get; }
    IDirect3DSurface AcquireBufferToUpdateContentWithHardwareProtection();
  }
}
namespace Windows.Graphics.Imaging {
  public sealed class BitmapDecoder : IBitmapFrame, IBitmapFrameWithSoftwareBitmap {
    public static Guid HeifDecoderId { get; }
    public static Guid WebpDecoderId { get; }
  }
  public sealed class BitmapEncoder {
    public static Guid HeifEncoderId { get; }
  }
}
namespace Windows.Management.Deployment {
  public enum DeploymentOptions : uint {
    ForceUpdateFromAnyVersion = (uint)262144,
  }
  public sealed class PackageManager {
    IAsyncOperationWithProgress&lt;DeploymentResult, DeploymentProgress&gt; DeprovisionPackageForAllUsersAsync(string packageFamilyName);
  }
  public enum RemovalOptions : uint {
    RemoveForAllUsers = (uint)524288,
  }
}
namespace Windows.Media.Audio {
  public sealed class CreateAudioDeviceInputNodeResult {
    HResult ExtendedError { get; }
  }
 public sealed class CreateAudioDeviceOutputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioFileInputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioFileOutputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioGraphResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateMediaSourceAudioInputNodeResult {
    HResult ExtendedError { get; }
  }
  public enum MixedRealitySpatialAudioFormatPolicy
  public sealed class SetDefaultSpatialAudioFormatResult
  public enum SetDefaultSpatialAudioFormatStatus
  public sealed class SpatialAudioDeviceConfiguration
  public sealed class SpatialAudioFormatConfiguration
  public static class SpatialAudioFormatSubtype
}
namespace Windows.Media.Control {
  public sealed class CurrentSessionChangedEventArgs
  public sealed class GlobalSystemMediaTransportControlsSession
  public sealed class GlobalSystemMediaTransportControlsSessionManager
  public sealed class GlobalSystemMediaTransportControlsSessionMediaProperties
  public sealed class GlobalSystemMediaTransportControlsSessionPlaybackControls
  public sealed class GlobalSystemMediaTransportControlsSessionPlaybackInfo
  public enum GlobalSystemMediaTransportControlsSessionPlaybackStatus
  public sealed class GlobalSystemMediaTransportControlsSessionTimelineProperties
  public sealed class MediaPropertiesChangedEventArgs
  public sealed class PlaybackInfoChangedEventArgs
  public sealed class SessionsChangedEventArgs
  public sealed class TimelinePropertiesChangedEventArgs
}
namespace Windows.Media.Core {
  public sealed class MediaStreamSample {
    IDirect3DSurface Direct3D11Surface { get; }
    public static MediaStreamSample CreateFromDirect3D11Surface(IDirect3DSurface surface, TimeSpan timestamp);
  }
}
namespace Windows.Media.Devices.Core {
  public sealed class CameraIntrinsics {
    public CameraIntrinsics(Vector2 focalLength, Vector2 principalPoint, Vector3 radialDistortion, Vector2 tangentialDistortion, uint imageWidth, uint imageHeight);
  }
}
namespace Windows.Media.Import {
  public enum PhotoImportContentTypeFilter {
    ImagesAndVideosFromCameraRoll = 3,
  }
  public sealed class PhotoImportItem {
    string Path { get; }
  }
}
namespace Windows.Media.MediaProperties {
  public sealed class ImageEncodingProperties : IMediaEncodingProperties {
    public static ImageEncodingProperties CreateHeif();
  }
  public static class MediaEncodingSubtypes {
    public static string Heif { get; }
  }
}
namespace Windows.Media.Protection.PlayReady {
  public static class PlayReadyStatics {
    public static IReference&lt;DateTime&gt; HardwareDRMDisabledAtTime { get; }
    public static IReference&lt;DateTime&gt; HardwareDRMDisabledUntilTime { get; }
    public static void ResetHardwareDRMDisabled();
  }
}
namespace Windows.Media.Streaming.Adaptive {
  public enum AdaptiveMediaSourceResourceType {
    MediaSegmentIndex = 5,
  }
}
namespace Windows.Networking.BackgroundTransfer {
  public enum BackgroundTransferPriority {
    Low = 2,
  }
}
namespace Windows.Networking.Connectivity {
  public sealed class ConnectionProfile {
    bool CanDelete { get; }
    IAsyncOperation&lt;ConnectionProfileDeleteStatus&gt; TryDeleteAsync();
  }
  public enum ConnectionProfileDeleteStatus
}
namespace Windows.Networking.NetworkOperators {
  public enum ESimOperationStatus {
    CardGeneralFailure = 13,
    ConfirmationCodeMissing = 14,
    EidMismatch = 18,
    InvalidMatchingId = 15,
    NoCorrespondingRequest = 23,
    NoEligibleProfileForThisDevice = 16,
    OperationAborted = 17,
    OperationProhibitedByProfileClass = 21,
    ProfileNotAvailableForNewBinding = 19,
    ProfileNotPresent = 22,
    ProfileNotReleasedByOperator = 20,
  }
}
namespace Windows.Perception {
  public sealed class PerceptionTimestamp {
    TimeSpan SystemRelativeTargetTime { get; }
  }
  public static class PerceptionTimestampHelper {
    public static PerceptionTimestamp FromSystemRelativeTargetTime(TimeSpan targetTime);
  }
}
namespace Windows.Perception.Spatial {
  public sealed class SpatialAnchorExporter
  public enum SpatialAnchorExportPurpose
  public sealed class SpatialAnchorExportSufficiency
  public sealed class SpatialLocation {
    Vector3 AbsoluteAngularAccelerationAxisAngle { get; }
    Vector3 AbsoluteAngularVelocityAxisAngle { get; }
  }
}
namespace Windows.Perception.Spatial.Preview {
  public static class SpatialGraphInteropPreview
}
namespace Windows.Services.Cortana {
  public sealed class CortanaActionableInsights
  public sealed class CortanaActionableInsightsOptions
}
namespace Windows.Services.Store {
  public sealed class StoreAppLicense {
    bool IsDiscLicense { get; }
  }
  public sealed class StoreContext {
    IAsyncOperation&lt;StoreRateAndReviewResult&gt; RequestRateAndReviewAppAsync();
    IAsyncOperation&lt;IVectorView&lt;StoreQueueItem&gt;&gt; SetInstallOrderForAssociatedStoreQueueItemsAsync(IIterable&lt;StoreQueueItem&gt; items);
  }
  public sealed class StoreQueueItem {
    IAsyncAction CancelInstallAsync();
    IAsyncAction PauseInstallAsync();
    IAsyncAction ResumeInstallAsync();
  }
  public sealed class StoreRateAndReviewResult
  public enum StoreRateAndReviewStatus
}
namespace Windows.Storage.Provider {
  public enum StorageProviderHydrationPolicyModifier : uint {
    AutoDehydrationAllowed = (uint)4,
  }
  public sealed class StorageProviderSyncRootInfo {
    Guid ProviderId { get; set; }
  }
}
namespace Windows.System {
  public sealed class AppUriHandlerHost
  public sealed class AppUriHandlerRegistration
  public sealed class AppUriHandlerRegistrationManager
  public static class Launcher {
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathAsync(string path);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathAsync(string path, FolderLauncherOptions options);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathForUserAsync(User user, string path);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathForUserAsync(User user, string path, FolderLauncherOptions options);
  }
}
namespace Windows.System.Preview {
  public enum HingeState
  public sealed class TwoPanelHingedDevicePosturePreview
  public sealed class TwoPanelHingedDevicePosturePreviewReading
  public sealed class TwoPanelHingedDevicePosturePreviewReadingChangedEventArgs
}
namespace Windows.System.Profile {
  public enum SystemOutOfBoxExperienceState
  public static class SystemSetupInfo
  public static class WindowsIntegrityPolicy
}
namespace Windows.System.Profile.SystemManufacturers {
  public sealed class SystemSupportDeviceInfo
  public static class SystemSupportInfo {
    public static SystemSupportDeviceInfo LocalDeviceInfo { get; }
  }
}
namespace Windows.System.RemoteSystems {
  public sealed class RemoteSystem {
    IVectorView&lt;RemoteSystemApp&gt; Apps { get; }
  }
  public sealed class RemoteSystemApp
  public sealed class RemoteSystemAppRegistration
  public sealed class RemoteSystemConnectionInfo
  public sealed class RemoteSystemConnectionRequest {
    RemoteSystemApp RemoteSystemApp { get; }
    public static RemoteSystemConnectionRequest CreateForApp(RemoteSystemApp remoteSystemApp);
  }
  public sealed class RemoteSystemWebAccountFilter : IRemoteSystemFilter
}
namespace Windows.System.Update {
  public enum SystemUpdateAttentionRequiredReason
  public sealed class SystemUpdateItem
  public enum SystemUpdateItemState
  public sealed class SystemUpdateLastErrorInfo
  public static class SystemUpdateManager
  public enum SystemUpdateManagerState
  public enum SystemUpdateStartInstallAction
}
namespace Windows.System.UserProfile {
  public sealed class AssignedAccessSettings
}
namespace Windows.UI.Accessibility {
  public sealed class ScreenReaderPositionChangedEventArgs
  public sealed class ScreenReaderService
}
namespace Windows.UI.Composition {
  public enum AnimationPropertyAccessMode
  public sealed class AnimationPropertyInfo : CompositionObject
  public sealed class BooleanKeyFrameAnimation : KeyFrameAnimation
  public class CompositionAnimation : CompositionObject, ICompositionAnimationBase {
    void SetExpressionReferenceParameter(string parameterName, IAnimationObject source);
  }
  public enum CompositionBatchTypes : uint {
    AllAnimations = (uint)5,
    InfiniteAnimation = (uint)4,
  }
  public sealed class CompositionGeometricClip : CompositionClip
  public class CompositionGradientBrush : CompositionBrush {
    CompositionMappingMode MappingMode { get; set; }
  }
  public enum CompositionMappingMode
  public class CompositionObject : IAnimationObject, IClosable {
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    public static void StartAnimationGroupWithIAnimationObject(IAnimationObject target, ICompositionAnimationBase animation);
    public static void StartAnimationWithIAnimationObject(IAnimationObject target, string propertyName, CompositionAnimation animation);
  }
  public sealed class Compositor : IClosable {
    BooleanKeyFrameAnimation CreateBooleanKeyFrameAnimation();
    CompositionGeometricClip CreateGeometricClip();
    CompositionGeometricClip CreateGeometricClip(CompositionGeometry geometry);
    RedirectVisual CreateRedirectVisual();
    RedirectVisual CreateRedirectVisual(Visual source);
  }
  public interface IAnimationObject
  public sealed class RedirectVisual : ContainerVisual
}
namespace Windows.UI.Composition.Interactions {
  public sealed class InteractionSourceConfiguration : CompositionObject
  public enum InteractionSourceRedirectionMode
  public sealed class InteractionTracker : CompositionObject {
    bool IsInertiaFromImpulse { get; }
    int TryUpdatePosition(Vector3 value, InteractionTrackerClampingOption option);
    int TryUpdatePositionBy(Vector3 amount, InteractionTrackerClampingOption option);
  }
  public enum InteractionTrackerClampingOption
  public sealed class InteractionTrackerInertiaStateEnteredArgs {
    bool IsInertiaFromImpulse { get; }
  }
  public class VisualInteractionSource : CompositionObject, ICompositionInteractionSource {
    InteractionSourceConfiguration PointerWheelConfig { get; }
  }
}
namespace Windows.UI.Input.Inking {
  public enum HandwritingLineHeight
  public sealed class PenAndInkSettings
  public enum PenHandedness
}
namespace Windows.UI.Input.Inking.Preview {
  public sealed class PalmRejectionDelayZonePreview : IClosable
}
namespace Windows.UI.Notifications {
  public sealed class ScheduledToastNotificationShowingEventArgs
  public sealed class ToastNotifier {
    event TypedEventHandler&lt;ToastNotifier, ScheduledToastNotificationShowingEventArgs&gt; ScheduledToastNotificationShowing;
  }
}
namespace Windows.UI.Shell {
  public enum SecurityAppKind
  public sealed class SecurityAppManager
  public struct SecurityAppManagerContract
  public enum SecurityAppState
  public enum SecurityAppSubstatus
  public sealed class TaskbarManager {
    IAsyncOperation&lt;bool&gt; IsSecondaryTilePinnedAsync(string tileId);
    IAsyncOperation&lt;bool&gt; RequestPinSecondaryTileAsync(SecondaryTile secondaryTile);
    IAsyncOperation&lt;bool&gt; TryUnpinSecondaryTileAsync(string tileId);
  }
}
namespace Windows.UI.StartScreen {
  public sealed class StartScreenManager {
    IAsyncOperation&lt;bool&gt; ContainsSecondaryTileAsync(string tileId);
    IAsyncOperation&lt;bool&gt; TryRemoveSecondaryTileAsync(string tileId);
  }
}
namespace Windows.UI.Text {
  public sealed class RichEditTextDocument : ITextDocument {
    void ClearUndoRedoHistory();
  }
}
namespace Windows.UI.Text.Core {
  public sealed class CoreTextLayoutRequest {
    CoreTextLayoutBounds LayoutBoundsVisualPixels { get; }
  }
}
namespace Windows.UI.ViewManagement {
  public enum ApplicationViewWindowingMode {
    CompactOverlay = 3,
    Maximized = 4,
  }
}
namespace Windows.UI.ViewManagement.Core {
  public sealed class CoreInputView {
    bool TryHide();
    bool TryShow();
    bool TryShow(CoreInputViewKind type);
  }
  public enum CoreInputViewKind
}
namespace Windows.UI.WebUI {
  public sealed class BackgroundActivatedEventArgs : IBackgroundActivatedEventArgs
  public delegate void BackgroundActivatedEventHandler(object sender, IBackgroundActivatedEventArgs eventArgs);
  public sealed class NewWebUIViewCreatedEventArgs
  public static class WebUIApplication {
    public static event BackgroundActivatedEventHandler BackgroundActivated;
    public static event EventHandler&lt;NewWebUIViewCreatedEventArgs&gt; NewWebUIViewCreated;
  }
  public sealed class WebUIView : IWebViewControl, IWebViewControl2
}
namespace Windows.UI.Xaml {
  public class BrushTransition
  public class ColorPaletteResources : ResourceDictionary
  public class DataTemplate : FrameworkTemplate, IElementFactory {
    UIElement GetElement(ElementFactoryGetArgs args);
    void RecycleElement(ElementFactoryRecycleArgs args);
  }
  public sealed class DebugSettings {
    bool FailFastOnErrors { get; set; }
  }
  public sealed class EffectiveViewportChangedEventArgs
  public class ElementFactoryGetArgs
  public class ElementFactoryRecycleArgs
  public class FrameworkElement : UIElement {
    bool IsLoaded { get; }
    event TypedEventHandler&lt;FrameworkElement, EffectiveViewportChangedEventArgs&gt; EffectiveViewportChanged;
    void InvalidateViewport();
  }
  public interface IElementFactory
  public class ScalarTransition
  public class UIElement : DependencyObject, IAnimationObject {
    bool CanBeScrollAnchor { get; set; }
    public static DependencyProperty CanBeScrollAnchorProperty { get; }
    Vector3 CenterPoint { get; set; }
    ScalarTransition OpacityTransition { get; set; }
    float Rotation { get; set; }
    Vector3 RotationAxis { get; set; }
    ScalarTransition RotationTransition { get; set; }
    Vector3 Scale { get; set; }
    Vector3Transition ScaleTransition { get; set; }
    Matrix4x4 TransformMatrix { get; set; }
    Vector3 Translation { get; set; }
    Vector3Transition TranslationTransition { get; set; }
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    virtual void PopulatePropertyInfoOverride(string propertyName, AnimationPropertyInfo animationPropertyInfo);
    void StartAnimation(ICompositionAnimationBase animation);
    void StopAnimation(ICompositionAnimationBase animation);
  }
  public class Vector3Transition
  public enum Vector3TransitionComponents : uint
}
namespace Windows.UI.Xaml.Automation {
  public sealed class AutomationElementIdentifiers {
    public static AutomationProperty IsDialogProperty { get; }
  }
  public sealed class AutomationProperties {
    public static DependencyProperty IsDialogProperty { get; }
    public static bool GetIsDialog(DependencyObject element);
    public static void SetIsDialog(DependencyObject element, bool value);
  }
}
namespace Windows.UI.Xaml.Automation.Peers {
  public class AppBarButtonAutomationPeer : ButtonAutomationPeer, IExpandCollapseProvider {
    ExpandCollapseState ExpandCollapseState { get; }
    void Collapse();
    void Expand();
  }
  public class AutomationPeer : DependencyObject {
    bool IsDialog();
    virtual bool IsDialogCore();
  }
  public class MenuBarAutomationPeer : FrameworkElementAutomationPeer
  public class MenuBarItemAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IInvokeProvider
}
namespace Windows.UI.Xaml.Controls {
  public sealed class AnchorRequestedEventArgs
  public class AppBarElementContainer : ContentControl, ICommandBarElement, ICommandBarElement2
  public sealed class AutoSuggestBox : ItemsControl {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
  }
  public enum BackgroundSizing
  public sealed class Border : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    BrushTransition BackgroundTransition { get; set; }
  }
  public class CalendarDatePicker : Control {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
  }
  public class ComboBox : Selector {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    bool IsEditable { get; set; }
    public static DependencyProperty IsEditableProperty { get; }
    string Text { get; set; }
    Style TextBoxStyle { get; set; }
    public static DependencyProperty TextBoxStyleProperty { get; }
    public static DependencyProperty TextProperty { get; }
    event TypedEventHandler&lt;ComboBox, ComboBoxTextSubmittedEventArgs&gt; TextSubmitted;
  }
  public sealed class ComboBoxTextSubmittedEventArgs
  public class CommandBarFlyout : FlyoutBase
  public class ContentPresenter : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    BrushTransition BackgroundTransition { get; set; }
  }
  public class Control : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    CornerRadius CornerRadius { get; set; }
    public static DependencyProperty CornerRadiusProperty { get; }
  }
  public class DataTemplateSelector : IElementFactory {
    UIElement GetElement(ElementFactoryGetArgs args);
    void RecycleElement(ElementFactoryRecycleArgs args);
  }
  public class DatePicker : Control {
    IReference&lt;DateTime&gt; SelectedDate { get; set; }
    public static DependencyProperty SelectedDateProperty { get; }
    event TypedEventHandler&lt;DatePicker, DatePickerSelectedValueChangedEventArgs&gt; SelectedDateChanged;
  }
  public sealed class DatePickerSelectedValueChangedEventArgs
  public class DropDownButton : Button
  public class DropDownButtonAutomationPeer : ButtonAutomationPeer, IExpandCollapseProvider
  public class Frame : ContentControl, INavigate {
    bool IsNavigationStackEnabled { get; set; }
    public static DependencyProperty IsNavigationStackEnabledProperty { get; }
    bool NavigateToType(TypeName sourcePageType, object parameter, FrameNavigationOptions navigationOptions);
  }
  public class Grid : Panel {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public class IconSourceElement : IconElement
  public interface IScrollAnchorProvider
  public class MenuBar : Control
  public class MenuBarItem : Control
  public class MenuBarItemFlyout : MenuFlyout
  public class NavigationView : ContentControl {
    UIElement ContentOverlay { get; set; }
    public static DependencyProperty ContentOverlayProperty { get; }
    bool IsPaneVisible { get; set; }
    public static DependencyProperty IsPaneVisibleProperty { get; }
    NavigationViewOverflowLabelMode OverflowLabelMode { get; set; }
    public static DependencyProperty OverflowLabelModeProperty { get; }
    UIElement PaneCustomContent { get; set; }
    public static DependencyProperty PaneCustomContentProperty { get; }
    NavigationViewPaneDisplayMode PaneDisplayMode { get; set; }
    public static DependencyProperty PaneDisplayModeProperty { get; }
    UIElement PaneHeader { get; set; }
    public static DependencyProperty PaneHeaderProperty { get; }
    NavigationViewSelectionFollowsFocus SelectionFollowsFocus { get; set; }
    public static DependencyProperty SelectionFollowsFocusProperty { get; }
    NavigationViewShoulderNavigationEnabled ShoulderNavigationEnabled { get; set; }
    public static DependencyProperty ShoulderNavigationEnabledProperty { get; }
    NavigationViewTemplateSettings TemplateSettings { get; }
    public static DependencyProperty TemplateSettingsProperty { get; }
  }
  public class NavigationViewItem : NavigationViewItemBase {
    bool SelectsOnInvoked { get; set; }
    public static DependencyProperty SelectsOnInvokedProperty { get; }
  }
  public sealed class NavigationViewItemInvokedEventArgs {
    NavigationViewItemBase InvokedItemContainer { get; }
    NavigationTransitionInfo RecommendedNavigationTransitionInfo { get; }
  }
  public enum NavigationViewOverflowLabelMode
  public enum NavigationViewPaneDisplayMode
  public sealed class NavigationViewSelectionChangedEventArgs {
    NavigationTransitionInfo RecommendedNavigationTransitionInfo { get; }
    NavigationViewItemBase SelectedItemContainer { get; }
  }
  public enum NavigationViewSelectionFollowsFocus
  public enum NavigationViewShoulderNavigationEnabled
  public class NavigationViewTemplateSettings : DependencyObject
  public class Panel : FrameworkElement {
    BrushTransition BackgroundTransition { get; set; }
  }
  public sealed class PasswordBox : Control {
    bool CanPasteClipboardContent { get; }
    public static DependencyProperty CanPasteClipboardContentProperty { get; }
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void PasteFromClipboard();
  }
  public class RelativePanel : Panel {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public class RichEditBox : Control {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase ProofingMenuFlyout { get; }
    public static DependencyProperty ProofingMenuFlyoutProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    RichEditTextDocument TextDocument { get; }
    event TypedEventHandler&lt;RichEditBox, RichEditBoxSelectionChangingEventArgs&gt; SelectionChanging;
  }
  public sealed class RichEditBoxSelectionChangingEventArgs
  public sealed class RichTextBlock : FrameworkElement {
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void CopySelectionToClipboard();
  }
  public sealed class ScrollContentPresenter : ContentPresenter {
    bool CanContentRenderOutsideBounds { get; set; }
    public static DependencyProperty CanContentRenderOutsideBoundsProperty { get; }
    bool SizesContentToTemplatedParent { get; set; }
    public static DependencyProperty SizesContentToTemplatedParentProperty { get; }
  }
  public sealed class ScrollViewer : ContentControl, IScrollAnchorProvider {
    bool CanContentRenderOutsideBounds { get; set; }
    public static DependencyProperty CanContentRenderOutsideBoundsProperty { get; }
    UIElement CurrentAnchor { get; }
    double HorizontalAnchorRatio { get; set; }
    public static DependencyProperty HorizontalAnchorRatioProperty { get; }
    bool ReduceViewportForCoreInputViewOcclusions { get; set; }
    public static DependencyProperty ReduceViewportForCoreInputViewOcclusionsProperty { get; }
    double VerticalAnchorRatio { get; set; }
    public static DependencyProperty VerticalAnchorRatioProperty { get; }
    event TypedEventHandler&lt;ScrollViewer, AnchorRequestedEventArgs&gt; AnchorRequested;
    public static bool GetCanContentRenderOutsideBounds(DependencyObject element);
    void RegisterAnchorCandidate(UIElement element);
    public static void SetCanContentRenderOutsideBounds(DependencyObject element, bool canContentRenderOutsideBounds);
    void UnregisterAnchorCandidate(UIElement element);
  }
  public class SplitButton : ContentControl
  public class SplitButtonAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IInvokeProvider
  public sealed class SplitButtonClickEventArgs
  public class StackPanel : Panel, IInsertionPanel, IScrollSnapPointsInfo {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public sealed class TextBlock : FrameworkElement {
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void CopySelectionToClipboard();
  }
  public class TextBox : Control {
    bool CanPasteClipboardContent { get; }
    public static DependencyProperty CanPasteClipboardContentProperty { get; }
    bool CanRedo { get; }
    public static DependencyProperty CanRedoProperty { get; }
    bool CanUndo { get; }
    public static DependencyProperty CanUndoProperty { get; }
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase ProofingMenuFlyout { get; }
    public static DependencyProperty ProofingMenuFlyoutProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    event TypedEventHandler&lt;TextBox, TextBoxSelectionChangingEventArgs&gt; SelectionChanging;
    void ClearUndoRedoHistory();
    void CopySelectionToClipboard();
    void CutSelectionToClipboard();
    void PasteFromClipboard();
    void Redo();
    void Undo();
  }
  public sealed class TextBoxSelectionChangingEventArgs
  public class TextCommandBarFlyout : CommandBarFlyout
  public class TimePicker : Control {
    IReference&lt;TimeSpan&gt; SelectedTime { get; set; }
    public static DependencyProperty SelectedTimeProperty { get; }
    event TypedEventHandler&lt;TimePicker, TimePickerSelectedValueChangedEventArgs&gt; SelectedTimeChanged;
  }
  public sealed class TimePickerSelectedValueChangedEventArgs
  public class ToggleSplitButton : SplitButton
  public class ToggleSplitButtonAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IToggleProvider
  public sealed class ToggleSplitButtonIsCheckedChangedEventArgs
  public class ToolTip : ContentControl {
    IReference&lt;Rect&gt; PlacementRect { get; set; }
    public static DependencyProperty PlacementRectProperty { get; }
  }
  public class TreeView : Control {
    bool CanDragItems { get; set; }
    public static DependencyProperty CanDragItemsProperty { get; }
    bool CanReorderItems { get; set; }
    public static DependencyProperty CanReorderItemsProperty { get; }
    Style ItemContainerStyle { get; set; }
    public static DependencyProperty ItemContainerStyleProperty { get; }
    StyleSelector ItemContainerStyleSelector { get; set; }
    public static DependencyProperty ItemContainerStyleSelectorProperty { get; }
    TransitionCollection ItemContainerTransitions { get; set; }
    public static DependencyProperty ItemContainerTransitionsProperty { get; }
    object ItemsSource { get; set; }
    public static DependencyProperty ItemsSourceProperty { get; }
    DataTemplate ItemTemplate { get; set; }
    public static DependencyProperty ItemTemplateProperty { get; }
    DataTemplateSelector ItemTemplateSelector { get; set; }
    public static DependencyProperty ItemTemplateSelectorProperty { get; }
    event TypedEventHandler&lt;TreeView, TreeViewDragItemsCompletedEventArgs&gt; DragItemsCompleted;
    event TypedEventHandler&lt;TreeView, TreeViewDragItemsStartingEventArgs&gt; DragItemsStarting;
    DependencyObject ContainerFromItem(object item);
    DependencyObject ContainerFromNode(TreeViewNode node);
    object ItemFromContainer(DependencyObject container);
    TreeViewNode NodeFromContainer(DependencyObject container);
  }
  public sealed class TreeViewCollapsedEventArgs {
    object Item { get; }
  }
  public sealed class TreeViewDragItemsCompletedEventArgs
  public sealed class TreeViewDragItemsStartingEventArgs
  public sealed class TreeViewExpandingEventArgs {
    object Item { get; }
  }
  public class TreeViewItem : ListViewItem {
    bool HasUnrealizedChildren { get; set; }
    public static DependencyProperty HasUnrealizedChildrenProperty { get; }
    object ItemsSource { get; set; }
    public static DependencyProperty ItemsSourceProperty { get; }
  }
  public sealed class WebView : FrameworkElement {
    event TypedEventHandler&lt;WebView, WebViewWebResourceRequestedEventArgs&gt; WebResourceRequested;
  }
  public sealed class WebViewWebResourceRequestedEventArgs
}
namespace Windows.UI.Xaml.Controls.Maps {
  public enum MapTileAnimationState
  public sealed class MapTileBitmapRequestedEventArgs {
    int FrameIndex { get; }
  }
 public class MapTileSource : DependencyObject {
    MapTileAnimationState AnimationState { get; }
    public static DependencyProperty AnimationStateProperty { get; }
    bool AutoPlay { get; set; }
    public static DependencyProperty AutoPlayProperty { get; }
    int FrameCount { get; set; }
    public static DependencyProperty FrameCountProperty { get; }
    TimeSpan FrameDuration { get; set; }
    public static DependencyProperty FrameDurationProperty { get; }
    void Pause();
    void Play();
    void Stop();
  }
  public sealed class MapTileUriRequestedEventArgs {
    int FrameIndex { get; }
  }
}
namespace Windows.UI.Xaml.Controls.Primitives {
  public class CommandBarFlyoutCommandBar : CommandBar
  public sealed class CommandBarFlyoutCommandBarTemplateSettings : DependencyObject
  public class FlyoutBase : DependencyObject {
    bool AreOpenCloseAnimationsEnabled { get; set; }
    public static DependencyProperty AreOpenCloseAnimationsEnabledProperty { get; }
    bool InputDevicePrefersPrimaryCommands { get; }
    public static DependencyProperty InputDevicePrefersPrimaryCommandsProperty { get; }
    bool IsOpen { get; }
    public static DependencyProperty IsOpenProperty { get; }
    FlyoutShowMode ShowMode { get; set; }
    public static DependencyProperty ShowModeProperty { get; }
    public static DependencyProperty TargetProperty { get; }
    void ShowAt(DependencyObject placementTarget, FlyoutShowOptions showOptions);
  }
  public enum FlyoutPlacementMode {
    Auto = 13,
    BottomEdgeAlignedLeft = 7,
    BottomEdgeAlignedRight = 8,
    LeftEdgeAlignedBottom = 10,
    LeftEdgeAlignedTop = 9,
    RightEdgeAlignedBottom = 12,
    RightEdgeAlignedTop = 11,
    TopEdgeAlignedLeft = 5,
    TopEdgeAlignedRight = 6,
  }
  public enum FlyoutShowMode
  public class FlyoutShowOptions
  public class NavigationViewItemPresenter : ContentControl
}
namespace Windows.UI.Xaml.Core.Direct {
  public interface IXamlDirectObject
  public sealed class XamlDirect
  public struct XamlDirectContract
  public enum XamlEventIndex
  public enum XamlPropertyIndex
  public enum XamlTypeIndex
}
namespace Windows.UI.Xaml.Hosting {
  public class DesktopWindowXamlSource : IClosable
  public sealed class DesktopWindowXamlSourceGotFocusEventArgs
  public sealed class DesktopWindowXamlSourceTakeFocusRequestedEventArgs
  public sealed class WindowsXamlManager : IClosable
  public enum XamlSourceFocusNavigationReason
  public sealed class XamlSourceFocusNavigationRequest
  public sealed class XamlSourceFocusNavigationResult
}
namespace Windows.UI.Xaml.Input {
  public sealed class CanExecuteRequestedEventArgs
  public sealed class ExecuteRequestedEventArgs
  public sealed class FocusManager {
    public static event EventHandler&lt;GettingFocusEventArgs&gt; GettingFocus;
    public static event EventHandler&lt;FocusManagerGotFocusEventArgs&gt; GotFocus;
    public static event EventHandler&lt;LosingFocusEventArgs&gt; LosingFocus;
    public static event EventHandler&lt;FocusManagerLostFocusEventArgs&gt; LostFocus;
  }
  public sealed class FocusManagerGotFocusEventArgs
  public sealed class FocusManagerLostFocusEventArgs
  public sealed class GettingFocusEventArgs : RoutedEventArgs {
    Guid CorrelationId { get; }
  }
  public sealed class LosingFocusEventArgs : RoutedEventArgs {
    Guid CorrelationId { get; }
  }
  public class StandardUICommand : XamlUICommand
  public enum StandardUICommandKind
  public class XamlUICommand : DependencyObject, ICommand
}
namespace Windows.UI.Xaml.Markup {
  public sealed class FullXamlMetadataProviderAttribute : Attribute
  public interface IXamlBindScopeDiagnostics
  public interface IXamlType2 : IXamlType
}
namespace Windows.UI.Xaml.Media {
  public class Brush : DependencyObject, IAnimationObject {
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    virtual void PopulatePropertyInfoOverride(string propertyName, AnimationPropertyInfo animationPropertyInfo);
  }
}
namespace Windows.UI.Xaml.Media.Animation {
  public class BasicConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public sealed class ConnectedAnimation {
    ConnectedAnimationConfiguration Configuration { get; set; }
  }
  public class ConnectedAnimationConfiguration
  public class DirectConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public class GravityConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public enum SlideNavigationTransitionEffect
  public sealed class SlideNavigationTransitionInfo : NavigationTransitionInfo {
    SlideNavigationTransitionEffect Effect { get; set; }
    public static DependencyProperty EffectProperty { get; }
  }
}
namespace Windows.UI.Xaml.Navigation {
  public class FrameNavigationOptions
}
namespace Windows.Web.UI {
  public interface IWebViewControl2
  public sealed class WebViewControlNewWindowRequestedEventArgs {
    IWebViewControl NewWindow { get; set; }
    Deferral GetDeferral();
  }
  public enum WebViewControlPermissionType {
    ImmersiveView = 6,
  }
}
namespace Windows.Web.UI.Interop {
  public sealed class WebViewControl : IWebViewControl, IWebViewControl2 {
    event TypedEventHandler&lt;WebViewControl, object&gt; GotFocus;
    event TypedEventHandler&lt;WebViewControl, object&gt; LostFocus;
    void AddInitializeScript(string script);
  }
}

</pre>
<h2>Removals:</h2>
<pre class="brush: plain; title: ; notranslate">

namespace Windows.Gaming.UI {
  public sealed class GameMonitor
  public enum GameMonitoringPermission
}

</pre>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/28/windows-10-sdk-preview-build-17744-available-now/">Windows 10 SDK Preview Build 17744 available now!</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></content:encoded>
			<wfw:commentRss>https://blogs.windows.com/buildingapps/2018/08/28/windows-10-sdk-preview-build-17744-available-now/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Windows 10 SDK Preview Build 17738 available now!</title>
		<link>https://blogs.windows.com/buildingapps/2018/08/21/windows-10-sdk-preview-build-17738-available-now/</link>
		<comments>https://blogs.windows.com/buildingapps/2018/08/21/windows-10-sdk-preview-build-17738-available-now/#respond</comments>
		<pubDate>Tue, 21 Aug 2018 17:30:10 +0000</pubDate>
		<dc:creator><![CDATA[Clint Rutkas]]></dc:creator>
				<category><![CDATA[PC]]></category>
		<category><![CDATA[MSIX]]></category>
		<category><![CDATA[SDK]]></category>
		<category><![CDATA[Visual Studio]]></category>
		<category><![CDATA[Windows 10 SDK Preview Build]]></category>

		<guid isPermaLink="false">http://blogs.windows.com/buildingapps/?p=54039</guid>
		<description><![CDATA[<p>Today, we released a new Windows 10 Preview Build of the SDK to be used in conjunction with Windows 10 Insider Preview (Build 17738 or greater). The Preview SDK Build 17738 contains bug fixes and under development changes to the API surface area. The Preview SDK can be downloaded from developer section on Windows Insider. For feedback and [&#8230;]</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/21/windows-10-sdk-preview-build-17738-available-now/">Windows 10 SDK Preview Build 17738 available now!</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p>Today, we released a new Windows 10 Preview Build of the SDK to be used in conjunction with <a href="https://insider.windows.com/">Windows 10 Insider Preview</a> (Build <strong>17738 </strong>or greater). The Preview SDK Build <strong>17738 </strong>contains bug fixes and under development changes to the API surface area.</p>
<p>The Preview SDK can be downloaded from <a href="https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewSDK">developer section on Windows Insider</a>.</p>
<p>For feedback and updates to the known issues, please see the <a href="https://social.msdn.microsoft.com/Forums/en-US/home?forum=Win10SDKToolsIssues">developer forum.</a> For new developer feature requests, head over to our <a href="https://wpdev.uservoice.com/">Windows Platform UserVoice.</a></p>
<h1>Things to note:</h1>
<ul>
<li>This build works in conjunction with previously released SDKs and Visual Studio 2017. You can install this SDK and still also continue to submit your apps that target Windows 10 build 1803 or earlier to the store.</li>
<li>The Windows SDK will now formally only be supported by Visual Studio 2017 and greater. You can download the Visual Studio 2017 <a href="https://www.visualstudio.com/downloads/">here</a>.</li>
<li>This build of the Windows SDK <strong>will</strong> only install on <a href="https://insider.windows.com/">Windows 10 Insider Preview</a> builds.</li>
<li>In order to assist with script access to the SDK, the ISO will also be able to be accessed through the following URL:  <a href="https://go.microsoft.com/fwlink/?prd=11966&amp;pver=1.0&amp;plcid=0x409&amp;clcid=0x409&amp;ar=Flight&amp;sar=Sdsurl&amp;o1=17738">https://go.microsoft.com/fwlink/?prd=11966&amp;pver=1.0&amp;plcid=0x409&amp;clcid=0x409&amp;ar=Flight&amp;sar=Sdsurl&amp;o1=17738</a> once the static URL is published.</li>
</ul>
<h1>C++/WinRT Update for build 17709 and beyond:</h1>
<p>This update introduces many improvements and fixes for C++/WinRT. Notably, it introduces the ability to build C++/WinRT without any dependency on the Windows SDK. This isn’t particularly interesting to the OS developer, but even in the OS repo it provides benefits because it does not itself include any Windows headers. Thus, a developer will typically pull in fewer or no dependencies inadvertently. This also means a dramatic reduction in the number of macros that a C++/WinRT developer must guard against. Removing the dependency on the Windows headers means that C++/WinRT is more portable and standards compliant and furthers our efforts to make it a cross-compiler and cross-platform library. It also means that the C++/WinRT headers will never be mangled by macros. If you previously relied on C++/WinRT to include various Windows headers that you will now have to include them yourself. It has always been good practice to always include any headers you depend on explicitly and not rely on another library to include them for you.</p>
<h2><strong>Highlights</strong></h2>
<p><strong>Support get_strong and get_weak to create delegates:</strong> This update allows a developer to use either get_strong or get_weak instead of a raw this pointer when creating a delegate pointing to a member function.</p>
<p><strong>Add async cancellation callback:</strong> The most frequently requested feature for C++/WinRT&#8217;s coroutine support has been the addition of a cancellation callback.</p>
<p><strong>Simplify the use of APIs expecting IBuffer parameters:</strong> Although most APIs prefer collections or arrays, enough APIs rely on IBuffer that it should be easier to use such APIs from C++. This update provides direct access to the data behind an IBuffer implementation using the same data naming convention used by the C++ standard library containers. This also avoids colliding with metadata names that conventionally begin with an uppercase letter.</p>
<p><strong>Conformance:</strong> Improved support for Clang and Visual C++’s stricter conformance modes.</p>
<p><strong>Improved code gen:</strong> Various improvements to reduce code size, improve inlining, and optimize factory caching.</p>
<p><strong>Remove unnecessary recursion:</strong> When the command line refers to a folder rather than a specific winmd, cppwinrt will no longer search recursively for winmd files. It causes performance problems in the OS build and can lead to usage errors that are hard to diagnose when developers inadvertently cause cppwinrt to consume more winmds than expected. The cppwinrt compiler also now handles duplicates more intelligently, making it more resilient to user error and poorly-formed winmd files.</p>
<p><strong>Declare both WINRT_CanUnloadNow and WINRT_GetActivationFactory in base.h:</strong> Callers don’t need to declare them directly. Their signatures have also changed, amounting to a breaking change. The declarations alleviate most of the pain of this change. The change is necessitated by the fact that C++/WinRT no longer depends on the Windows headers and this change removes the dependency on the types from the Windows headers.</p>
<p><strong>Harden smart pointers:</strong> The event revokers didn’t revoke when move-assigned a new value. This lead me to take a closer look at the smart pointer classes and I noticed that they were not reliably handling self-assignment. This is rooted in the com_ptr class template that most of the others rely on. I fixed com_ptr and updated the event revokers to handle move semantics correctly to ensure that they revoke upon assignment. The handle class template has also been hardened by the removal of the implicit constructor that made it easy to write incorrect code. This also turned bugs in the OS into compiler errors fixed in this PR.</p>
<h2><strong>Breaking Changes</strong></h2>
<p>Support for non-WinRT interfaces is disabled by default. To enable, simply #include &lt;unknwn.h&gt; before any C++/WinRT headers.</p>
<p>winrt::get_abi(winrt::hstring) now returns void* instead of HSTRING. Code requiring the HSTRING ABI can simply use a static_cast.</p>
<p>winrt::put_abi(winrt::hstring) returns void** instead of HSTRING*. Code requiring the HSTRING ABI can simply use a reinterpret_cast.</p>
<p>HRESULT is now projected as winrt::hresult. Code requiring an HRESULT can simply static_cast if you need to do type checking or support type traits, but it is otherwise convertible as long as &lt;unknwn.h&gt; is included first.</p>
<p>GUID is now projected as winrt::guid. Code implementing APIs with GUID parameters must use winrt::guid instead, but it is otherwise convertible as long as &lt;unknwn.h&gt; is included first.</p>
<p>The signatures of WINRT_CanUnloadNow and WINRT_GetActivationFactory has changed. Code must not declare these functions at all and instead include winrt/base.h to include their declarations.</p>
<p>The winrt::handle constructor is now explicit. Code assigning a raw handle value must call the attach method instead.</p>
<p>winrt::clock::from_FILETIME has been deprecated. Code should use winrt::clock::from_file_time instead.</p>
<h1>What&#8217;s New:</h1>
<h2><strong>MSIX Support</strong></h2>
<p>It’s finally here! You can now package your applications as MSIX. These applications can be installed and run on any device with <strong>17682</strong> build or later.</p>
<p>To package your application with MSIX, use the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh446767(v=vs.85).aspx">MakeAppx tool</a>. To install the application – just click on the MSIX file. To understand more about MSIX, watch this introductory video: <a href="https://channel9.msdn.com/events/Build/2018/BRK2432?term=msix%20inside%20and%20out">link</a></p>
<p>Feedback and comments are welcome on our MSIX community: <a href="http://aka.ms/MSIXCommunity">http://aka.ms/MSIXCommunity</a></p>
<p>MSIX is not currently supported by the App Certification Kit nor the Microsoft Store at this time.</p>
<h2><strong>MC.EXE</strong></h2>
<p>We’ve made some important changes to the C/C++ ETW code generation of mc.exe (Message Compiler):</p>
<p>The “-mof” parameter is deprecated. This parameter instructs MC.exe to generate ETW code that is compatible with Windows XP and earlier. Support for the “-mof” parameter will be removed in a future version of mc.exe.</p>
<p>As long as the “-mof” parameter is not used, the generated C/C++ header is now compatible with both kernel-mode and user-mode, regardless of whether “-km” or “-um” was specified on the command line. The header will use the _ETW_KM_ macro to automatically determine whether it is being compiled for kernel-mode or user-mode and will call the appropriate ETW APIs for each mode.</p>
<ul>
<li>The only remaining difference between “-km” and “-um” is that the EventWrite[EventName] macros generated with “-km” have an Activity ID parameter while the EventWrite[EventName] macros generated with “-um” do not have an Activity ID parameter.</li>
</ul>
<p>The EventWrite[EventName] macros now default to calling EventWriteTransfer (user mode) or EtwWriteTransfer (kernel mode). Previously, the EventWrite[EventName] macros defaulted to calling EventWrite (user mode) or EtwWrite (kernel mode).</p>
<ul>
<li>The generated header now supports several customization macros. For example, you can set the MCGEN_EVENTWRITETRANSFER macro if you need the generated macros to call something other than EventWriteTransfer.</li>
<li>The manifest supports new attributes.
<ul>
<li>Event “name”: non-localized event name.</li>
<li>Event “attributes”: additional key-value metadata for an event such as filename, line number, component name, function name.</li>
<li>Event “tags”: 28-bit value with user-defined semantics (per-event).</li>
<li>Field “tags”: 28-bit value with user-defined semantics (per-field – can be applied to “data” or “struct” elements).</li>
</ul>
</li>
</ul>
<ul>
<li>You can now define “provider traits” in the manifest (e.g. provider group). If provider traits are used in the manifest, the EventRegister[ProviderName] macro will automatically register them.</li>
<li>MC will now report an error if a localized message file is missing a string. (Previously MC would silently generate a corrupt message resource.)</li>
<li>MC can now generate Unicode (utf-8 or utf-16) output with the “-cp utf-8” or “-cp utf-16” parameters.</li>
</ul>
<h1>Known Issues:</h1>
<p>The SDK headers are generated with types in the “ABI” namespace. This is done to avoid conflicts with C++/CX and C++/WinRT clients that need to consume types directly at the ABI layer[1]. By default, types emitted by MIDL are *<strong>not</strong>* put in the ABI namespace, however this has the potential to introduce conflicts from teams attempting to consume ABI types from Windows WinRT MIDL generated headers and non-Windows WinRT MIDL generated headers (this is especially challenging if the non-Windows header references Windows types).</p>
<p>To ensure that developers have a consistent view of the WinRT API surface, validation has been added to the generated headers to ensure that the ABI prefix is consistent between the Windows headers and user generated headers. If you encounter an error like:</p>
<p>5&gt;c:\program files (x86)\windows kits\10\include\10.0.17687.0\winrt\windows.foundation.h(83): error C2220: warning treated as error &#8211; no &#8216;object&#8217; file generated</p>
<p>5&gt;c:\program files (x86)\windows kits\10\include\10.0.17687.0\winrt\windows.foundation.h(83): warning C4005: &#8216;CHECK_NS_PREFIX_STATE&#8217;: macro redefinition</p>
<p>5&gt;g:\&lt;PATH TO YOUR HEADER HERE&gt;(41): note: see previous definition of &#8216;CHECK_NS_PREFIX_STATE&#8217;</p>
<p>It means that some of your MIDL generated headers are inconsistent with the system generated headers.</p>
<p>There are two ways to fix this:</p>
<ul>
<li><strong>Preferred:</strong> Compile your IDL file with the /ns_prefix MIDL command line switch. This will cause all your types to be moved to the ABI namespace consistent with the Windows headers. This may require code changes in your code however.</li>
<li><strong>Alternate:</strong> Add #define DISABLE_NS_PREFIX_CHECKS before including the Windows headers. This will suppress the validation.</li>
</ul>
<h2><strong>Windows App Certification Kit Crashes</strong></h2>
<p>The Windows App Certification Kit will crash when running. To avoid this failure we recommend not installing the Windows App Certification Kit. You can uncheck this option during setup.</p>
<h1>API Updates, Additions and Removals</h1>
<p>When targeting new APIs, consider writing your app to be adaptive in order to run correctly on the widest number of Windows 10 devices. Please see <a href="https://blogs.windows.com/buildingapps/2015/09/15/dynamically-detecting-features-with-api-contracts-10-by-10/#HdHAk5RVtCg6bW4O.97">Dynamically detecting features with API contracts (10 by 10)</a> for more information.</p>
<p>The following APIs have been added to the platform since the release of 17134. The APIs listed below have been removed.</p>
<h1>Additions:</h1>
<pre class="brush: csharp; title: ; notranslate">

namespace Windows.AI.MachineLearning {
  public interface ILearningModelFeatureDescriptor
  public interface ILearningModelFeatureValue
  public interface ILearningModelOperatorProvider
  public sealed class ImageFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class ImageFeatureValue : ILearningModelFeatureValue
  public interface ITensor : ILearningModelFeatureValue
  public sealed class LearningModel : IClosable
  public sealed class LearningModelBinding : IIterable&lt;IKeyValuePair&lt;string, object&gt;&gt;, IMapView&lt;string, object&gt;
  public sealed class LearningModelDevice
  public enum LearningModelDeviceKind
  public sealed class LearningModelEvaluationResult
  public enum LearningModelFeatureKind
  public sealed class LearningModelSession : IClosable
  public struct MachineLearningContract
  public sealed class MapFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class SequenceFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class TensorBoolean : ILearningModelFeatureValue, ITensor
  public sealed class TensorDouble : ILearningModelFeatureValue, ITensor
  public sealed class TensorFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class TensorFloat : ILearningModelFeatureValue, ITensor
  public sealed class TensorFloat16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt32Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt64Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt8Bit : ILearningModelFeatureValue, ITensor
  public enum TensorKind
  public sealed class TensorString : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt32Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt64Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt8Bit : ILearningModelFeatureValue, ITensor
}
namespace Windows.ApplicationModel {
  public sealed class AppInstallerInfo
  public sealed class LimitedAccessFeatureRequestResult
  public static class LimitedAccessFeatures
  public enum LimitedAccessFeatureStatus
  public sealed class Package {
    IAsyncOperation&lt;PackageUpdateAvailabilityResult&gt; CheckUpdateAvailabilityAsync();
    AppInstallerInfo GetAppInstallerInfo();
  }
  public enum PackageUpdateAvailability
  public sealed class PackageUpdateAvailabilityResult
}
namespace Windows.ApplicationModel.Calls {
  public sealed class VoipCallCoordinator {
    IAsyncOperation&lt;VoipPhoneCallResourceReservationStatus&gt; ReserveCallResourcesAsync();
  }
}
namespace Windows.ApplicationModel.Chat {
  public static class ChatCapabilitiesManager {
    public static IAsyncOperation&lt;ChatCapabilities&gt; GetCachedCapabilitiesAsync(string address, string transportId);
    public static IAsyncOperation&lt;ChatCapabilities&gt; GetCapabilitiesFromNetworkAsync(string address, string transportId);
  }
  public static class RcsManager {
    public static event EventHandler&lt;object&gt; TransportListChanged;
  }
}
namespace Windows.ApplicationModel.DataTransfer {
  public static class Clipboard {
    public static event EventHandler&lt;ClipboardHistoryChangedEventArgs&gt; HistoryChanged;
    public static event EventHandler&lt;object&gt; HistoryEnabledChanged;
    public static event EventHandler&lt;object&gt; RoamingEnabledChanged;
    public static bool ClearHistory();
    public static bool DeleteItemFromHistory(ClipboardHistoryItem item);
    public static IAsyncOperation&lt;ClipboardHistoryItemsResult&gt; GetHistoryItemsAsync();
    public static bool IsHistoryEnabled();
    public static bool IsRoamingEnabled();
    public static bool SetContentWithOptions(DataPackage content, ClipboardContentOptions options);
    public static SetHistoryItemAsContentStatus SetHistoryItemAsContent(ClipboardHistoryItem item);
  }
  public sealed class ClipboardContentOptions
  public sealed class ClipboardHistoryChangedEventArgs
  public sealed class ClipboardHistoryItem
  public sealed class ClipboardHistoryItemsResult
  public enum ClipboardHistoryItemsResultStatus
  public sealed class DataPackagePropertySetView : IIterable&lt;IKeyValuePair&lt;string, object&gt;&gt;, IMapView&lt;string, object&gt; {
    bool IsFromRoamingClipboard { get; }
    string SourceDisplayName { get; }
  }
  public enum SetHistoryItemAsContentStatus
}
namespace Windows.ApplicationModel.Store.Preview {
  public enum DeliveryOptimizationDownloadMode
  public enum DeliveryOptimizationDownloadModeSource
  public sealed class DeliveryOptimizationSettings
  public static class StoreConfiguration {
    public static bool IsPinToDesktopSupported();
    public static bool IsPinToStartSupported();
    public static bool IsPinToTaskbarSupported();
    public static void PinToDesktop(string appPackageFamilyName);
    public static void PinToDesktopForUser(User user, string appPackageFamilyName);
  }
}
namespace Windows.ApplicationModel.Store.Preview.InstallControl {
  public enum AppInstallationToastNotificationMode
  public sealed class AppInstallItem {
    AppInstallationToastNotificationMode CompletedInstallToastNotificationMode { get; set; }
    AppInstallationToastNotificationMode InstallInProgressToastNotificationMode { get; set; }
    bool PinToDesktopAfterInstall { get; set; }
    bool PinToStartAfterInstall { get; set; }
    bool PinToTaskbarAfterInstall { get; set; }
  }
  public sealed class AppInstallManager {
    bool CanInstallForAllUsers { get; }
  }
  public sealed class AppInstallOptions {
    string CampaignId { get; set; }
    AppInstallationToastNotificationMode CompletedInstallToastNotificationMode { get; set; }
    string ExtendedCampaignId { get; set; }
    bool InstallForAllUsers { get; set; }
    AppInstallationToastNotificationMode InstallInProgressToastNotificationMode { get; set; }
    bool PinToDesktopAfterInstall { get; set; }
    bool PinToStartAfterInstall { get; set; }
    bool PinToTaskbarAfterInstall { get; set; }
    bool StageButDoNotInstall { get; set; }
  }
  public sealed class AppUpdateOptions {
    bool AutomaticallyDownloadAndInstallUpdateIfFound { get; set; }
  }
}
namespace Windows.ApplicationModel.UserActivities {
  public sealed class UserActivity {
    bool IsRoamable { get; set; }
  }
}
namespace Windows.Data.Text {
  public sealed class TextPredictionGenerator {
    CoreTextInputScope InputScope { get; set; }
    IAsyncOperation&lt;IVectorView&lt;string&gt;&gt; GetCandidatesAsync(string input, uint maxCandidates, TextPredictionOptions predictionOptions, IIterable&lt;string&gt; previousStrings);
    IAsyncOperation&lt;IVectorView&lt;string&gt;&gt; GetNextWordCandidatesAsync(uint maxCandidates, IIterable&lt;string&gt; previousStrings);
  }
  public enum TextPredictionOptions : uint
}
namespace Windows.Devices.Display.Core {
  public sealed class DisplayAdapter
  public enum DisplayBitsPerChannel : uint
  public sealed class DisplayDevice
  public enum DisplayDeviceCapability
  public sealed class DisplayFence
  public sealed class DisplayManager : IClosable
  public sealed class DisplayManagerChangedEventArgs
  public sealed class DisplayManagerDisabledEventArgs
  public sealed class DisplayManagerEnabledEventArgs
  public enum DisplayManagerOptions : uint
  public sealed class DisplayManagerPathsFailedOrInvalidatedEventArgs
  public enum DisplayManagerResult
  public sealed class DisplayManagerResultWithState
  public sealed class DisplayModeInfo
  public enum DisplayModeQueryOptions : uint
  public sealed class DisplayPath
  public enum DisplayPathScaling
  public enum DisplayPathStatus
  public struct DisplayPresentationRate
  public sealed class DisplayPrimaryDescription
  public enum DisplayRotation
  public sealed class DisplayScanout
  public sealed class DisplaySource
  public sealed class DisplayState
  public enum DisplayStateApplyOptions : uint
  public enum DisplayStateFunctionalizeOptions : uint
  public sealed class DisplayStateOperationResult
  public enum DisplayStateOperationStatus
  public sealed class DisplaySurface
  public sealed class DisplayTarget
  public enum DisplayTargetPersistence
  public sealed class DisplayTask
  public sealed class DisplayTaskPool
  public enum DisplayTaskSignalKind
  public sealed class DisplayView
  public sealed class DisplayWireFormat
  public enum DisplayWireFormatColorSpace
  public enum DisplayWireFormatEotf
  public enum DisplayWireFormatHdrMetadata
  public enum DisplayWireFormatPixelEncoding
}
namespace Windows.Devices.Enumeration {
  public enum DeviceInformationKind {
    DevicePanel = 8,
  }
  public sealed class DeviceInformationPairing {
    public static bool TryRegisterForAllInboundPairingRequestsWithProtectionLevel(DevicePairingKinds pairingKindsSupported, DevicePairingProtectionLevel minProtectionLevel);
  }
}
namespace Windows.Devices.Enumeration.Pnp {
  public enum PnpObjectType {
    DevicePanel = 8,
  }
}
namespace Windows.Devices.Lights {
  public sealed class LampArray
  public enum LampArrayKind
  public sealed class LampInfo
  public enum LampPurposes : uint
}
namespace Windows.Devices.Lights.Effects {
  public interface ILampArrayEffect
  public sealed class LampArrayBitmapEffect : ILampArrayEffect
  public sealed class LampArrayBitmapRequestedEventArgs
  public sealed class LampArrayBlinkEffect : ILampArrayEffect
  public sealed class LampArrayColorRampEffect : ILampArrayEffect
  public sealed class LampArrayCustomEffect : ILampArrayEffect
  public enum LampArrayEffectCompletionBehavior
  public sealed class LampArrayEffectPlaylist : IIterable&lt;ILampArrayEffect&gt;, IVectorView&lt;ILampArrayEffect&gt;
  public enum LampArrayEffectStartMode
  public enum LampArrayRepetitionMode
  public sealed class LampArraySolidEffect : ILampArrayEffect
  public sealed class LampArrayUpdateRequestedEventArgs
}
namespace Windows.Devices.PointOfService {
  public sealed class BarcodeScannerCapabilities {
    bool IsVideoPreviewSupported { get; }
  }
  public sealed class ClaimedBarcodeScanner : IClosable {
    event TypedEventHandler&lt;ClaimedBarcodeScanner, ClaimedBarcodeScannerClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedBarcodeScannerClosedEventArgs
  public sealed class ClaimedCashDrawer : IClosable {
    event TypedEventHandler&lt;ClaimedCashDrawer, ClaimedCashDrawerClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedCashDrawerClosedEventArgs
  public sealed class ClaimedLineDisplay : IClosable {
    event TypedEventHandler&lt;ClaimedLineDisplay, ClaimedLineDisplayClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedLineDisplayClosedEventArgs
  public sealed class ClaimedMagneticStripeReader : IClosable {
    event TypedEventHandler&lt;ClaimedMagneticStripeReader, ClaimedMagneticStripeReaderClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedMagneticStripeReaderClosedEventArgs
  public sealed class ClaimedPosPrinter : IClosable {
    event TypedEventHandler&lt;ClaimedPosPrinter, ClaimedPosPrinterClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedPosPrinterClosedEventArgs
}
namespace Windows.Devices.PointOfService.Provider {
  public sealed class BarcodeScannerDisableScannerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerEnableScannerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerFrameReader : IClosable
  public sealed class BarcodeScannerFrameReaderFrameArrivedEventArgs
  public sealed class BarcodeScannerGetSymbologyAttributesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerHideVideoPreviewRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerProviderConnection : IClosable {
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync();
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync(BitmapPixelFormat preferredFormat);
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync(BitmapPixelFormat preferredFormat, BitmapSize preferredSize);
  }
  public sealed class BarcodeScannerSetActiveSymbologiesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerSetSymbologyAttributesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerStartSoftwareTriggerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerStopSoftwareTriggerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerVideoFrame : IClosable
}
namespace Windows.Devices.Sensors {
  public sealed class HingeAngleReading
  public sealed class HingeAngleSensor
  public sealed class HingeAngleSensorReadingChangedEventArgs
  public sealed class SimpleOrientationSensor {
    public static IAsyncOperation&lt;SimpleOrientationSensor&gt; FromIdAsync(string deviceId);
    public static string GetDeviceSelector();
  }
}
namespace Windows.Devices.SmartCards {
  public static class KnownSmartCardAppletIds
  public sealed class SmartCardAppletIdGroup {
    string Description { get; set; }
    IRandomAccessStreamReference Logo { get; set; }
    ValueSet Properties { get; }
    bool SecureUserAuthenticationRequired { get; set; }
  }
  public sealed class SmartCardAppletIdGroupRegistration {
    string SmartCardReaderId { get; }
    IAsyncAction SetPropertiesAsync(ValueSet props);
  }
}
namespace Windows.Devices.WiFi {
  public enum WiFiPhyKind {
    HE = 10,
  }
}
namespace Windows.Foundation {
  public static class GuidHelper
}
namespace Windows.Globalization {
  public static class CurrencyIdentifiers {
    public static string MRU { get; }
    public static string SSP { get; }
    public static string STN { get; }
    public static string VES { get; }
  }
}
namespace Windows.Graphics.Capture {
  public sealed class Direct3D11CaptureFramePool : IClosable {
    public static Direct3D11CaptureFramePool CreateFreeThreaded(IDirect3DDevice device, DirectXPixelFormat pixelFormat, int numberOfBuffers, SizeInt32 size);
  }
  public sealed class GraphicsCaptureItem {
    public static GraphicsCaptureItem CreateFromVisual(Visual visual);
  }
}
namespace Windows.Graphics.Display.Core {
  public enum HdmiDisplayHdrOption {
    DolbyVisionLowLatency = 3,
  }
  public sealed class HdmiDisplayMode {
    bool IsDolbyVisionLowLatencySupported { get; }
  }
}
namespace Windows.Graphics.Holographic {
  public sealed class HolographicCamera {
    bool IsHardwareContentProtectionEnabled { get; set; }
    bool IsHardwareContentProtectionSupported { get; }
  }
  public sealed class HolographicQuadLayerUpdateParameters {
    bool CanAcquireWithHardwareProtection { get; }
    IDirect3DSurface AcquireBufferToUpdateContentWithHardwareProtection();
  }
}
namespace Windows.Graphics.Imaging {
  public sealed class BitmapDecoder : IBitmapFrame, IBitmapFrameWithSoftwareBitmap {
    public static Guid HeifDecoderId { get; }
    public static Guid WebpDecoderId { get; }
  }
  public sealed class BitmapEncoder {
    public static Guid HeifEncoderId { get; }
  }
}
namespace Windows.Management.Deployment {
  public enum DeploymentOptions : uint {
    ForceUpdateFromAnyVersion = (uint)262144,
  }
  public sealed class PackageManager {
    IAsyncOperationWithProgress&lt;DeploymentResult, DeploymentProgress&gt; DeprovisionPackageForAllUsersAsync(string packageFamilyName);
  }
  public enum RemovalOptions : uint {
    RemoveForAllUsers = (uint)524288,
  }
}
namespace Windows.Media.Audio {
  public sealed class CreateAudioDeviceInputNodeResult {
    HResult ExtendedError { get; }
  }
 public sealed class CreateAudioDeviceOutputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioFileInputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioFileOutputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioGraphResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateMediaSourceAudioInputNodeResult {
    HResult ExtendedError { get; }
  }
  public enum MixedRealitySpatialAudioFormatPolicy
  public sealed class SetDefaultSpatialAudioFormatResult
  public enum SetDefaultSpatialAudioFormatStatus
  public sealed class SpatialAudioDeviceConfiguration
  public sealed class SpatialAudioFormatConfiguration
  public static class SpatialAudioFormatSubtype
}
namespace Windows.Media.Control {
  public sealed class CurrentSessionChangedEventArgs
  public sealed class GlobalSystemMediaTransportControlsSession
  public sealed class GlobalSystemMediaTransportControlsSessionManager
  public sealed class GlobalSystemMediaTransportControlsSessionMediaProperties
  public sealed class GlobalSystemMediaTransportControlsSessionPlaybackControls
  public sealed class GlobalSystemMediaTransportControlsSessionPlaybackInfo
  public enum GlobalSystemMediaTransportControlsSessionPlaybackStatus
  public sealed class GlobalSystemMediaTransportControlsSessionTimelineProperties
  public sealed class MediaPropertiesChangedEventArgs
  public sealed class PlaybackInfoChangedEventArgs
  public sealed class SessionsChangedEventArgs
  public sealed class TimelinePropertiesChangedEventArgs
}
namespace Windows.Media.Core {
  public sealed class MediaStreamSample {
    IDirect3DSurface Direct3D11Surface { get; }
    public static MediaStreamSample CreateFromDirect3D11Surface(IDirect3DSurface surface, TimeSpan timestamp);
  }
}
namespace Windows.Media.Devices.Core {
  public sealed class CameraIntrinsics {
    public CameraIntrinsics(Vector2 focalLength, Vector2 principalPoint, Vector3 radialDistortion, Vector2 tangentialDistortion, uint imageWidth, uint imageHeight);
  }
}
namespace Windows.Media.Import {
  public enum PhotoImportContentTypeFilter {
    ImagesAndVideosFromCameraRoll = 3,
  }
  public sealed class PhotoImportItem {
    string Path { get; }
  }
}
namespace Windows.Media.MediaProperties {
  public sealed class ImageEncodingProperties : IMediaEncodingProperties {
    public static ImageEncodingProperties CreateHeif();
  }
  public static class MediaEncodingSubtypes {
    public static string Heif { get; }
  }
}
namespace Windows.Media.Protection.PlayReady {
  public static class PlayReadyStatics {
    public static IReference&lt;DateTime&gt; HardwareDRMDisabledAtTime { get; }
    public static IReference&lt;DateTime&gt; HardwareDRMDisabledUntilTime { get; }
    public static void ResetHardwareDRMDisabled();
  }
}
namespace Windows.Media.Streaming.Adaptive {
  public enum AdaptiveMediaSourceResourceType {
    MediaSegmentIndex = 5,
  }
}
namespace Windows.Networking.BackgroundTransfer {
  public enum BackgroundTransferPriority {
    Low = 2,
  }
}
namespace Windows.Networking.Connectivity {
  public sealed class ConnectionProfile {
    bool CanDelete { get; }
    IAsyncOperation&lt;ConnectionProfileDeleteStatus&gt; TryDeleteAsync();
  }
  public enum ConnectionProfileDeleteStatus
}
namespace Windows.Networking.NetworkOperators {
  public enum ESimOperationStatus {
    CardGeneralFailure = 13,
    ConfirmationCodeMissing = 14,
    EidMismatch = 18,
    InvalidMatchingId = 15,
    NoCorrespondingRequest = 23,
    NoEligibleProfileForThisDevice = 16,
    OperationAborted = 17,
    OperationProhibitedByProfileClass = 21,
    ProfileNotAvailableForNewBinding = 19,
    ProfileNotPresent = 22,
    ProfileNotReleasedByOperator = 20,
  }
}
namespace Windows.Perception {
  public sealed class PerceptionTimestamp {
    TimeSpan SystemRelativeTargetTime { get; }
  }
  public static class PerceptionTimestampHelper {
    public static PerceptionTimestamp FromSystemRelativeTargetTime(TimeSpan targetTime);
  }
}
namespace Windows.Perception.Spatial {
  public sealed class SpatialAnchorExporter
  public enum SpatialAnchorExportPurpose
  public sealed class SpatialAnchorExportSufficiency
  public sealed class SpatialLocation {
    Vector3 AbsoluteAngularAccelerationAxisAngle { get; }
    Vector3 AbsoluteAngularVelocityAxisAngle { get; }
  }
}
namespace Windows.Perception.Spatial.Preview {
  public static class SpatialGraphInteropPreview
}
namespace Windows.Services.Cortana {
  public sealed class CortanaActionableInsights
  public sealed class CortanaActionableInsightsOptions
}
namespace Windows.Services.Store {
  public sealed class StoreAppLicense {
    bool IsDiscLicense { get; }
  }
  public sealed class StoreContext {
    IAsyncOperation&lt;StoreRateAndReviewResult&gt; RequestRateAndReviewAppAsync();
    IAsyncOperation&lt;IVectorView&lt;StoreQueueItem&gt;&gt; SetInstallOrderForAssociatedStoreQueueItemsAsync(IIterable&lt;StoreQueueItem&gt; items);
  }
  public sealed class StoreQueueItem {
    IAsyncAction CancelInstallAsync();
    IAsyncAction PauseInstallAsync();
    IAsyncAction ResumeInstallAsync();
  }
  public sealed class StoreRateAndReviewResult
  public enum StoreRateAndReviewStatus
}
namespace Windows.Storage.Provider {
  public enum StorageProviderHydrationPolicyModifier : uint {
    AutoDehydrationAllowed = (uint)4,
  }
  public sealed class StorageProviderSyncRootInfo {
    Guid ProviderId { get; set; }
  }
}
namespace Windows.System {
  public sealed class AppUriHandlerHost
  public sealed class AppUriHandlerRegistration
  public sealed class AppUriHandlerRegistrationManager
  public static class Launcher {
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathAsync(string path);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathAsync(string path, FolderLauncherOptions options);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathForUserAsync(User user, string path);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathForUserAsync(User user, string path, FolderLauncherOptions options);
  }
}
namespace Windows.System.Preview {
  public enum HingeState
  public sealed class TwoPanelHingedDevicePosturePreview
  public sealed class TwoPanelHingedDevicePosturePreviewReading
  public sealed class TwoPanelHingedDevicePosturePreviewReadingChangedEventArgs
}
namespace Windows.System.Profile {
  public enum SystemOutOfBoxExperienceState
  public static class SystemSetupInfo
  public static class WindowsIntegrityPolicy
}
namespace Windows.System.Profile.SystemManufacturers {
  public sealed class SystemSupportDeviceInfo
  public static class SystemSupportInfo {
    public static SystemSupportDeviceInfo LocalDeviceInfo { get; }
  }
}
namespace Windows.System.RemoteSystems {
  public sealed class RemoteSystem {
    IVectorView&lt;RemoteSystemApp&gt; Apps { get; }
  }
  public sealed class RemoteSystemApp
  public sealed class RemoteSystemAppRegistration
  public sealed class RemoteSystemConnectionInfo
  public sealed class RemoteSystemConnectionRequest {
    RemoteSystemApp RemoteSystemApp { get; }
    public static RemoteSystemConnectionRequest CreateForApp(RemoteSystemApp remoteSystemApp);
  }
  public sealed class RemoteSystemWebAccountFilter : IRemoteSystemFilter
}
namespace Windows.System.Update {
  public enum SystemUpdateAttentionRequiredReason
  public sealed class SystemUpdateItem
  public enum SystemUpdateItemState
  public sealed class SystemUpdateLastErrorInfo
  public static class SystemUpdateManager
  public enum SystemUpdateManagerState
  public enum SystemUpdateStartInstallAction
}
namespace Windows.System.UserProfile {
  public sealed class AssignedAccessSettings
}
namespace Windows.UI.Accessibility {
  public sealed class ScreenReaderPositionChangedEventArgs
  public sealed class ScreenReaderService
}
namespace Windows.UI.Composition {
  public enum AnimationPropertyAccessMode
  public sealed class AnimationPropertyInfo : CompositionObject
  public sealed class BooleanKeyFrameAnimation : KeyFrameAnimation
  public class CompositionAnimation : CompositionObject, ICompositionAnimationBase {
    void SetExpressionReferenceParameter(string parameterName, IAnimationObject source);
  }
  public enum CompositionBatchTypes : uint {
    AllAnimations = (uint)5,
    InfiniteAnimation = (uint)4,
  }
  public sealed class CompositionGeometricClip : CompositionClip
  public class CompositionGradientBrush : CompositionBrush {
    CompositionMappingMode MappingMode { get; set; }
  }
  public enum CompositionMappingMode
  public class CompositionObject : IAnimationObject, IClosable {
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    public static void StartAnimationGroupWithIAnimationObject(IAnimationObject target, ICompositionAnimationBase animation);
    public static void StartAnimationWithIAnimationObject(IAnimationObject target, string propertyName, CompositionAnimation animation);
  }
  public sealed class Compositor : IClosable {
    BooleanKeyFrameAnimation CreateBooleanKeyFrameAnimation();
    CompositionGeometricClip CreateGeometricClip();
    CompositionGeometricClip CreateGeometricClip(CompositionGeometry geometry);
    RedirectVisual CreateRedirectVisual();
    RedirectVisual CreateRedirectVisual(Visual source);
  }
  public interface IAnimationObject
  public sealed class RedirectVisual : ContainerVisual
}
namespace Windows.UI.Composition.Interactions {
  public sealed class InteractionSourceConfiguration : CompositionObject
  public enum InteractionSourceRedirectionMode
  public sealed class InteractionTracker : CompositionObject {
    bool IsInertiaFromImpulse { get; }
    int TryUpdatePosition(Vector3 value, InteractionTrackerClampingOption option);
    int TryUpdatePositionBy(Vector3 amount, InteractionTrackerClampingOption option);
  }
  public enum InteractionTrackerClampingOption
  public sealed class InteractionTrackerInertiaStateEnteredArgs {
    bool IsInertiaFromImpulse { get; }
  }
  public class VisualInteractionSource : CompositionObject, ICompositionInteractionSource {
    InteractionSourceConfiguration PointerWheelConfig { get; }
  }
}
namespace Windows.UI.Input.Inking {
  public enum HandwritingLineHeight
  public sealed class PenAndInkSettings
  public enum PenHandedness
}
namespace Windows.UI.Input.Inking.Preview {
  public sealed class PalmRejectionDelayZonePreview : IClosable
}
namespace Windows.UI.Notifications {
  public sealed class ScheduledToastNotificationShowingEventArgs
  public sealed class ToastNotifier {
    event TypedEventHandler&lt;ToastNotifier, ScheduledToastNotificationShowingEventArgs&gt; ScheduledToastNotificationShowing;
  }
}
namespace Windows.UI.Shell {
  public enum SecurityAppKind
  public sealed class SecurityAppManager
  public struct SecurityAppManagerContract
  public enum SecurityAppState
  public enum SecurityAppSubstatus
  public sealed class TaskbarManager {
    IAsyncOperation&lt;bool&gt; IsSecondaryTilePinnedAsync(string tileId);
    IAsyncOperation&lt;bool&gt; RequestPinSecondaryTileAsync(SecondaryTile secondaryTile);
    IAsyncOperation&lt;bool&gt; TryUnpinSecondaryTileAsync(string tileId);
  }
}
namespace Windows.UI.StartScreen {
  public sealed class StartScreenManager {
    IAsyncOperation&lt;bool&gt; ContainsSecondaryTileAsync(string tileId);
    IAsyncOperation&lt;bool&gt; TryRemoveSecondaryTileAsync(string tileId);
  }
}
namespace Windows.UI.Text {
  public sealed class RichEditTextDocument : ITextDocument {
    void ClearUndoRedoHistory();
  }
}
namespace Windows.UI.Text.Core {
  public sealed class CoreTextLayoutRequest {
    CoreTextLayoutBounds LayoutBoundsVisualPixels { get; }
  }
}
namespace Windows.UI.ViewManagement {
  public enum ApplicationViewWindowingMode {
    CompactOverlay = 3,
    Maximized = 4,
  }
}
namespace Windows.UI.ViewManagement.Core {
  public sealed class CoreInputView {
    bool TryHide();
    bool TryShow();
    bool TryShow(CoreInputViewKind type);
  }
  public enum CoreInputViewKind
}
namespace Windows.UI.WebUI {
  public sealed class BackgroundActivatedEventArgs : IBackgroundActivatedEventArgs
  public delegate void BackgroundActivatedEventHandler(object sender, IBackgroundActivatedEventArgs eventArgs);
  public sealed class NewWebUIViewCreatedEventArgs
  public static class WebUIApplication {
    public static event BackgroundActivatedEventHandler BackgroundActivated;
    public static event EventHandler&lt;NewWebUIViewCreatedEventArgs&gt; NewWebUIViewCreated;
  }
  public sealed class WebUIView : IWebViewControl, IWebViewControl2
}
namespace Windows.UI.Xaml {
  public class BrushTransition
  public class ColorPaletteResources : ResourceDictionary
  public class DataTemplate : FrameworkTemplate, IElementFactory {
    UIElement GetElement(ElementFactoryGetArgs args);
    void RecycleElement(ElementFactoryRecycleArgs args);
  }
  public sealed class DebugSettings {
    bool FailFastOnErrors { get; set; }
  }
  public sealed class EffectiveViewportChangedEventArgs
  public class ElementFactoryGetArgs
  public class ElementFactoryRecycleArgs
  public class FrameworkElement : UIElement {
    bool IsLoaded { get; }
    event TypedEventHandler&lt;FrameworkElement, EffectiveViewportChangedEventArgs&gt; EffectiveViewportChanged;
    void InvalidateViewport();
  }
  public interface IElementFactory
  public class ScalarTransition
  public class UIElement : DependencyObject, IAnimationObject {
    bool CanBeScrollAnchor { get; set; }
    public static DependencyProperty CanBeScrollAnchorProperty { get; }
    Vector3 CenterPoint { get; set; }
    ScalarTransition OpacityTransition { get; set; }
    float Rotation { get; set; }
    Vector3 RotationAxis { get; set; }
    ScalarTransition RotationTransition { get; set; }
    Vector3 Scale { get; set; }
    Vector3Transition ScaleTransition { get; set; }
    Matrix4x4 TransformMatrix { get; set; }
    Vector3 Translation { get; set; }
    Vector3Transition TranslationTransition { get; set; }
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    virtual void PopulatePropertyInfoOverride(string propertyName, AnimationPropertyInfo animationPropertyInfo);
    void StartAnimation(ICompositionAnimationBase animation);
    void StopAnimation(ICompositionAnimationBase animation);
  }
  public class Vector3Transition
  public enum Vector3TransitionComponents : uint
}
namespace Windows.UI.Xaml.Automation {
  public sealed class AutomationElementIdentifiers {
    public static AutomationProperty IsDialogProperty { get; }
  }
  public sealed class AutomationProperties {
    public static DependencyProperty IsDialogProperty { get; }
    public static bool GetIsDialog(DependencyObject element);
    public static void SetIsDialog(DependencyObject element, bool value);
  }
}
namespace Windows.UI.Xaml.Automation.Peers {
  public class AppBarButtonAutomationPeer : ButtonAutomationPeer, IExpandCollapseProvider {
    ExpandCollapseState ExpandCollapseState { get; }
    void Collapse();
    void Expand();
  }
  public class AutomationPeer : DependencyObject {
    bool IsDialog();
    virtual bool IsDialogCore();
  }
  public class MenuBarAutomationPeer : FrameworkElementAutomationPeer
  public class MenuBarItemAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IInvokeProvider
}
namespace Windows.UI.Xaml.Controls {
  public sealed class AnchorRequestedEventArgs
  public class AppBarElementContainer : ContentControl, ICommandBarElement, ICommandBarElement2
  public sealed class AutoSuggestBox : ItemsControl {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
  }
  public enum BackgroundSizing
  public sealed class Border : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    BrushTransition BackgroundTransition { get; set; }
  }
  public class CalendarDatePicker : Control {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
  }
  public class ComboBox : Selector {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    bool IsEditable { get; set; }
    public static DependencyProperty IsEditableProperty { get; }
    string Text { get; set; }
    Style TextBoxStyle { get; set; }
    public static DependencyProperty TextBoxStyleProperty { get; }
    public static DependencyProperty TextProperty { get; }
    event TypedEventHandler&lt;ComboBox, ComboBoxTextSubmittedEventArgs&gt; TextSubmitted;
  }
  public sealed class ComboBoxTextSubmittedEventArgs
  public class CommandBarFlyout : FlyoutBase
  public class ContentPresenter : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    BrushTransition BackgroundTransition { get; set; }
  }
  public class Control : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    CornerRadius CornerRadius { get; set; }
    public static DependencyProperty CornerRadiusProperty { get; }
  }
  public class DataTemplateSelector : IElementFactory {
    UIElement GetElement(ElementFactoryGetArgs args);
    void RecycleElement(ElementFactoryRecycleArgs args);
  }
  public class DatePicker : Control {
    IReference&lt;DateTime&gt; SelectedDate { get; set; }
    public static DependencyProperty SelectedDateProperty { get; }
    event TypedEventHandler&lt;DatePicker, DatePickerSelectedValueChangedEventArgs&gt; SelectedDateChanged;
  }
  public sealed class DatePickerSelectedValueChangedEventArgs
  public class DropDownButton : Button
  public class DropDownButtonAutomationPeer : ButtonAutomationPeer, IExpandCollapseProvider
  public class Frame : ContentControl, INavigate {
    bool IsNavigationStackEnabled { get; set; }
    public static DependencyProperty IsNavigationStackEnabledProperty { get; }
    bool NavigateToType(TypeName sourcePageType, object parameter, FrameNavigationOptions navigationOptions);
  }
  public class Grid : Panel {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public class IconSourceElement : IconElement
  public interface IScrollAnchorProvider
  public class MenuBar : Control
  public class MenuBarItem : Control
  public class MenuBarItemFlyout : MenuFlyout
  public class NavigationView : ContentControl {
    UIElement ContentOverlay { get; set; }
    public static DependencyProperty ContentOverlayProperty { get; }
    bool IsPaneVisible { get; set; }
    public static DependencyProperty IsPaneVisibleProperty { get; }
    NavigationViewOverflowLabelMode OverflowLabelMode { get; set; }
    public static DependencyProperty OverflowLabelModeProperty { get; }
    UIElement PaneCustomContent { get; set; }
    public static DependencyProperty PaneCustomContentProperty { get; }
    NavigationViewPaneDisplayMode PaneDisplayMode { get; set; }
    public static DependencyProperty PaneDisplayModeProperty { get; }
    UIElement PaneHeader { get; set; }
    public static DependencyProperty PaneHeaderProperty { get; }
    NavigationViewSelectionFollowsFocus SelectionFollowsFocus { get; set; }
    public static DependencyProperty SelectionFollowsFocusProperty { get; }
    NavigationViewShoulderNavigationEnabled ShoulderNavigationEnabled { get; set; }
    public static DependencyProperty ShoulderNavigationEnabledProperty { get; }
    NavigationViewTemplateSettings TemplateSettings { get; }
    public static DependencyProperty TemplateSettingsProperty { get; }
  }
  public class NavigationViewItem : NavigationViewItemBase {
    bool SelectsOnInvoked { get; set; }
    public static DependencyProperty SelectsOnInvokedProperty { get; }
  }
  public sealed class NavigationViewItemInvokedEventArgs {
    NavigationViewItemBase InvokedItemContainer { get; }
    NavigationTransitionInfo RecommendedNavigationTransitionInfo { get; }
  }
  public enum NavigationViewOverflowLabelMode
  public enum NavigationViewPaneDisplayMode
  public sealed class NavigationViewSelectionChangedEventArgs {
    NavigationTransitionInfo RecommendedNavigationTransitionInfo { get; }
    NavigationViewItemBase SelectedItemContainer { get; }
  }
  public enum NavigationViewSelectionFollowsFocus
  public enum NavigationViewShoulderNavigationEnabled
  public class NavigationViewTemplateSettings : DependencyObject
  public class Panel : FrameworkElement {
    BrushTransition BackgroundTransition { get; set; }
  }
  public sealed class PasswordBox : Control {
    bool CanPasteClipboardContent { get; }
    public static DependencyProperty CanPasteClipboardContentProperty { get; }
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void PasteFromClipboard();
  }
  public class RelativePanel : Panel {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public class RichEditBox : Control {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase ProofingMenuFlyout { get; }
    public static DependencyProperty ProofingMenuFlyoutProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    RichEditTextDocument TextDocument { get; }
    event TypedEventHandler&lt;RichEditBox, RichEditBoxSelectionChangingEventArgs&gt; SelectionChanging;
  }
  public sealed class RichEditBoxSelectionChangingEventArgs
  public sealed class RichTextBlock : FrameworkElement {
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void CopySelectionToClipboard();
  }
  public sealed class ScrollContentPresenter : ContentPresenter {
    bool CanContentRenderOutsideBounds { get; set; }
    public static DependencyProperty CanContentRenderOutsideBoundsProperty { get; }
    bool SizesContentToTemplatedParent { get; set; }
    public static DependencyProperty SizesContentToTemplatedParentProperty { get; }
  }
  public sealed class ScrollViewer : ContentControl, IScrollAnchorProvider {
    bool CanContentRenderOutsideBounds { get; set; }
    public static DependencyProperty CanContentRenderOutsideBoundsProperty { get; }
    UIElement CurrentAnchor { get; }
    double HorizontalAnchorRatio { get; set; }
    public static DependencyProperty HorizontalAnchorRatioProperty { get; }
    bool ReduceViewportForCoreInputViewOcclusions { get; set; }
    public static DependencyProperty ReduceViewportForCoreInputViewOcclusionsProperty { get; }
    double VerticalAnchorRatio { get; set; }
    public static DependencyProperty VerticalAnchorRatioProperty { get; }
    event TypedEventHandler&lt;ScrollViewer, AnchorRequestedEventArgs&gt; AnchorRequested;
    public static bool GetCanContentRenderOutsideBounds(DependencyObject element);
    void RegisterAnchorCandidate(UIElement element);
    public static void SetCanContentRenderOutsideBounds(DependencyObject element, bool canContentRenderOutsideBounds);
    void UnregisterAnchorCandidate(UIElement element);
  }
  public class SplitButton : ContentControl
  public class SplitButtonAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IInvokeProvider
  public sealed class SplitButtonClickEventArgs
  public class StackPanel : Panel, IInsertionPanel, IScrollSnapPointsInfo {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public sealed class TextBlock : FrameworkElement {
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void CopySelectionToClipboard();
  }
  public class TextBox : Control {
    bool CanPasteClipboardContent { get; }
    public static DependencyProperty CanPasteClipboardContentProperty { get; }
    bool CanRedo { get; }
    public static DependencyProperty CanRedoProperty { get; }
    bool CanUndo { get; }
    public static DependencyProperty CanUndoProperty { get; }
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase ProofingMenuFlyout { get; }
    public static DependencyProperty ProofingMenuFlyoutProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    event TypedEventHandler&lt;TextBox, TextBoxSelectionChangingEventArgs&gt; SelectionChanging;
    void ClearUndoRedoHistory();
    void CopySelectionToClipboard();
    void CutSelectionToClipboard();
    void PasteFromClipboard();
    void Redo();
    void Undo();
  }
  public sealed class TextBoxSelectionChangingEventArgs
  public class TextCommandBarFlyout : CommandBarFlyout
  public class TimePicker : Control {
    IReference&lt;TimeSpan&gt; SelectedTime { get; set; }
    public static DependencyProperty SelectedTimeProperty { get; }
    event TypedEventHandler&lt;TimePicker, TimePickerSelectedValueChangedEventArgs&gt; SelectedTimeChanged;
  }
  public sealed class TimePickerSelectedValueChangedEventArgs
  public class ToggleSplitButton : SplitButton
  public class ToggleSplitButtonAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IToggleProvider
  public sealed class ToggleSplitButtonIsCheckedChangedEventArgs
  public class ToolTip : ContentControl {
    IReference&lt;Rect&gt; PlacementRect { get; set; }
    public static DependencyProperty PlacementRectProperty { get; }
  }
  public class TreeView : Control {
    bool CanDragItems { get; set; }
    public static DependencyProperty CanDragItemsProperty { get; }
    bool CanReorderItems { get; set; }
    public static DependencyProperty CanReorderItemsProperty { get; }
    Style ItemContainerStyle { get; set; }
    public static DependencyProperty ItemContainerStyleProperty { get; }
    StyleSelector ItemContainerStyleSelector { get; set; }
    public static DependencyProperty ItemContainerStyleSelectorProperty { get; }
    TransitionCollection ItemContainerTransitions { get; set; }
    public static DependencyProperty ItemContainerTransitionsProperty { get; }
    object ItemsSource { get; set; }
    public static DependencyProperty ItemsSourceProperty { get; }
    DataTemplate ItemTemplate { get; set; }
    public static DependencyProperty ItemTemplateProperty { get; }
    DataTemplateSelector ItemTemplateSelector { get; set; }
    public static DependencyProperty ItemTemplateSelectorProperty { get; }
    event TypedEventHandler&lt;TreeView, TreeViewDragItemsCompletedEventArgs&gt; DragItemsCompleted;
    event TypedEventHandler&lt;TreeView, TreeViewDragItemsStartingEventArgs&gt; DragItemsStarting;
    DependencyObject ContainerFromItem(object item);
    DependencyObject ContainerFromNode(TreeViewNode node);
    object ItemFromContainer(DependencyObject container);
    TreeViewNode NodeFromContainer(DependencyObject container);
  }
  public sealed class TreeViewCollapsedEventArgs {
    object Item { get; }
  }
  public sealed class TreeViewDragItemsCompletedEventArgs
  public sealed class TreeViewDragItemsStartingEventArgs
  public sealed class TreeViewExpandingEventArgs {
    object Item { get; }
  }
  public class TreeViewItem : ListViewItem {
    bool HasUnrealizedChildren { get; set; }
    public static DependencyProperty HasUnrealizedChildrenProperty { get; }
    object ItemsSource { get; set; }
    public static DependencyProperty ItemsSourceProperty { get; }
  }
  public sealed class WebView : FrameworkElement {
    event TypedEventHandler&lt;WebView, WebViewWebResourceRequestedEventArgs&gt; WebResourceRequested;
  }
  public sealed class WebViewWebResourceRequestedEventArgs
}
namespace Windows.UI.Xaml.Controls.Maps {
  public enum MapTileAnimationState
  public sealed class MapTileBitmapRequestedEventArgs {
    int FrameIndex { get; }
  }
 public class MapTileSource : DependencyObject {
    MapTileAnimationState AnimationState { get; }
    public static DependencyProperty AnimationStateProperty { get; }
    bool AutoPlay { get; set; }
    public static DependencyProperty AutoPlayProperty { get; }
    int FrameCount { get; set; }
    public static DependencyProperty FrameCountProperty { get; }
    TimeSpan FrameDuration { get; set; }
    public static DependencyProperty FrameDurationProperty { get; }
    void Pause();
    void Play();
    void Stop();
  }
  public sealed class MapTileUriRequestedEventArgs {
    int FrameIndex { get; }
  }
}
namespace Windows.UI.Xaml.Controls.Primitives {
  public class CommandBarFlyoutCommandBar : CommandBar
  public sealed class CommandBarFlyoutCommandBarTemplateSettings : DependencyObject
  public class FlyoutBase : DependencyObject {
    bool AreOpenCloseAnimationsEnabled { get; set; }
    public static DependencyProperty AreOpenCloseAnimationsEnabledProperty { get; }
    bool InputDevicePrefersPrimaryCommands { get; }
    public static DependencyProperty InputDevicePrefersPrimaryCommandsProperty { get; }
    bool IsOpen { get; }
    public static DependencyProperty IsOpenProperty { get; }
    FlyoutShowMode ShowMode { get; set; }
    public static DependencyProperty ShowModeProperty { get; }
    public static DependencyProperty TargetProperty { get; }
    void ShowAt(DependencyObject placementTarget, FlyoutShowOptions showOptions);
  }
  public enum FlyoutPlacementMode {
    Auto = 13,
    BottomEdgeAlignedLeft = 7,
    BottomEdgeAlignedRight = 8,
    LeftEdgeAlignedBottom = 10,
    LeftEdgeAlignedTop = 9,
    RightEdgeAlignedBottom = 12,
    RightEdgeAlignedTop = 11,
    TopEdgeAlignedLeft = 5,
    TopEdgeAlignedRight = 6,
  }
  public enum FlyoutShowMode
  public class FlyoutShowOptions
  public class NavigationViewItemPresenter : ContentControl
}
namespace Windows.UI.Xaml.Core.Direct {
  public interface IXamlDirectObject
  public sealed class XamlDirect
  public struct XamlDirectContract
  public enum XamlEventIndex
  public enum XamlPropertyIndex
  public enum XamlTypeIndex
}
namespace Windows.UI.Xaml.Hosting {
  public class DesktopWindowXamlSource : IClosable
  public sealed class DesktopWindowXamlSourceGotFocusEventArgs
  public sealed class DesktopWindowXamlSourceTakeFocusRequestedEventArgs
  public sealed class WindowsXamlManager : IClosable
  public enum XamlSourceFocusNavigationReason
  public sealed class XamlSourceFocusNavigationRequest
  public sealed class XamlSourceFocusNavigationResult
}
namespace Windows.UI.Xaml.Input {
  public sealed class CanExecuteRequestedEventArgs
  public sealed class ExecuteRequestedEventArgs
  public sealed class FocusManager {
    public static event EventHandler&lt;GettingFocusEventArgs&gt; GettingFocus;
    public static event EventHandler&lt;FocusManagerGotFocusEventArgs&gt; GotFocus;
    public static event EventHandler&lt;LosingFocusEventArgs&gt; LosingFocus;
    public static event EventHandler&lt;FocusManagerLostFocusEventArgs&gt; LostFocus;
  }
  public sealed class FocusManagerGotFocusEventArgs
  public sealed class FocusManagerLostFocusEventArgs
  public sealed class GettingFocusEventArgs : RoutedEventArgs {
    Guid CorrelationId { get; }
  }
  public sealed class LosingFocusEventArgs : RoutedEventArgs {
    Guid CorrelationId { get; }
  }
  public class StandardUICommand : XamlUICommand
  public enum StandardUICommandKind
  public class XamlUICommand : DependencyObject, ICommand
}
namespace Windows.UI.Xaml.Markup {
  public sealed class FullXamlMetadataProviderAttribute : Attribute
  public interface IXamlBindScopeDiagnostics
  public interface IXamlType2 : IXamlType
}
namespace Windows.UI.Xaml.Media {
  public class Brush : DependencyObject, IAnimationObject {
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    virtual void PopulatePropertyInfoOverride(string propertyName, AnimationPropertyInfo animationPropertyInfo);
  }
}
namespace Windows.UI.Xaml.Media.Animation {
  public class BasicConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public sealed class ConnectedAnimation {
    ConnectedAnimationConfiguration Configuration { get; set; }
  }
  public class ConnectedAnimationConfiguration
  public class DirectConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public class GravityConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public enum SlideNavigationTransitionEffect
  public sealed class SlideNavigationTransitionInfo : NavigationTransitionInfo {
    SlideNavigationTransitionEffect Effect { get; set; }
    public static DependencyProperty EffectProperty { get; }
  }
}
namespace Windows.UI.Xaml.Navigation {
  public class FrameNavigationOptions
}
namespace Windows.Web.UI {
  public interface IWebViewControl2
  public sealed class WebViewControlNewWindowRequestedEventArgs {
    IWebViewControl NewWindow { get; set; }
    Deferral GetDeferral();
  }
  public enum WebViewControlPermissionType {
    ImmersiveView = 6,
  }
}
namespace Windows.Web.UI.Interop {
  public sealed class WebViewControl : IWebViewControl, IWebViewControl2 {
    event TypedEventHandler&lt;WebViewControl, object&gt; GotFocus;
    event TypedEventHandler&lt;WebViewControl, object&gt; LostFocus;
    void AddInitializeScript(string script);
  }
}

</pre>
<h1>Removals:</h1>
<pre class="brush: plain; title: ; notranslate">

namespace Windows.Gaming.UI {
  public sealed class GameMonitor
  public enum GameMonitoringPermission
}

</pre>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/21/windows-10-sdk-preview-build-17738-available-now/">Windows 10 SDK Preview Build 17738 available now!</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></content:encoded>
			<wfw:commentRss>https://blogs.windows.com/buildingapps/2018/08/21/windows-10-sdk-preview-build-17738-available-now/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Important dates regarding apps with Windows Phone 8.x and earlier and Windows 8/8.1 packages submitted to Microsoft Store</title>
		<link>https://blogs.windows.com/buildingapps/2018/08/20/important-dates-regarding-apps-with-windows-phone-8-x-and-earlier-and-windows-8-8-1-packages-submitted-to-microsoft-store/</link>
		<comments>https://blogs.windows.com/buildingapps/2018/08/20/important-dates-regarding-apps-with-windows-phone-8-x-and-earlier-and-windows-8-8-1-packages-submitted-to-microsoft-store/#comments</comments>
		<pubDate>Mon, 20 Aug 2018 16:00:02 +0000</pubDate>
		<dc:creator><![CDATA[Microsoft Store Team]]></dc:creator>
				<category><![CDATA[PC]]></category>
		<category><![CDATA[Apps]]></category>
		<category><![CDATA[microsoft store]]></category>
		<category><![CDATA[UWP]]></category>

		<guid isPermaLink="false">http://blogs.windows.com/buildingapps/?p=53979</guid>
		<description><![CDATA[<p>As a part of our Windows device life cycle, Microsoft Store will soon stop accepting new apps with Windows Phone 8.x or earlier or Windows 8/8.1 packages (XAP and APPX). Soon after that date, we will stop distributing app updates to Windows Phone 8.x or earlier and Windows 8/8.1 devices; at that time, updates will only be made [&#8230;]</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/20/important-dates-regarding-apps-with-windows-phone-8-x-and-earlier-and-windows-8-8-1-packages-submitted-to-microsoft-store/">Important dates regarding apps with Windows Phone 8.x and earlier and Windows 8/8.1 packages submitted to Microsoft Store</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p>As a part of our Windows device life cycle, Microsoft Store will soon stop accepting new apps with Windows Phone 8.x or earlier or Windows 8/8.1 packages (XAP and APPX). Soon after that date, we will stop distributing app updates to Windows Phone 8.x or earlier and Windows 8/8.1 devices; at that time, updates will only be made available to customers using Windows 10 devices.</p>
<p>Take note of the following dates so you can effectively plan your development cycles:</p>
<ul>
<li><b>October 31</b><b>st</b><b>, 2018</b> – <b>Microsoft will stop accepting new app submissions with Windows Phone 8.x or earlier </b><b>or</b><b> Windows 8/8.1 packages (XAP </b><b>or</b><b> APPX)</b>
<ul>
<li>This will not affect existing apps with packages targeting Windows Phone 8.x or earlier and/or Windows 8/8.1. You can continue to submit updates to these apps as described below.</li>
</ul>
</li>
</ul>
<ul>
<li><b>July 1</b><b>st</b><b>, 2019</b> – <b>Microsoft will stop </b><b>distributing </b><b>app updates to W</b><b>indows </b><b>P</b><b>hone </b><b>8.x or earlier devices.</b>
<ul>
<li>You’ll still be able to publish updates to all apps (including those with Windows Phone 8.x or earlier packages). However, these updates will only be made available to Windows 10 devices.</li>
</ul>
</li>
</ul>
<ul>
<li><b>July 1</b><b>st</b><b>, 2023</b> – <b>Microsoft will stop</b><b> distributing app updates to Windows 8/8.1 devices.</b>
<ul>
<li>You’ll still be able to publish updates to all apps (including those with Windows 8/8.1 packages). However, these updates will only be made available to Windows 10 devices.</li>
</ul>
</li>
</ul>
<p>We encourage you to explore how you can <strong><a href="https://docs.microsoft.com/en-us/windows/uwp/porting/">port your existing app to the Universal Windows Platform (UWP)</a></strong> where you can create a single Windows 10 app package that your customers can install onto all device families. You can learn more about UWP apps <strong><a href="https://docs.microsoft.com/en-us/windows/uwp/get-started/">here</a></strong>.</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/20/important-dates-regarding-apps-with-windows-phone-8-x-and-earlier-and-windows-8-8-1-packages-submitted-to-microsoft-store/">Important dates regarding apps with Windows Phone 8.x and earlier and Windows 8/8.1 packages submitted to Microsoft Store</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></content:encoded>
			<wfw:commentRss>https://blogs.windows.com/buildingapps/2018/08/20/important-dates-regarding-apps-with-windows-phone-8-x-and-earlier-and-windows-8-8-1-packages-submitted-to-microsoft-store/feed/</wfw:commentRss>
		<slash:comments>5</slash:comments>
		</item>
		<item>
		<title>Windows 10 SDK Preview Build 17733 available now!</title>
		<link>https://blogs.windows.com/buildingapps/2018/08/16/windows-10-sdk-preview-build-17733-available-now/</link>
		<comments>https://blogs.windows.com/buildingapps/2018/08/16/windows-10-sdk-preview-build-17733-available-now/#respond</comments>
		<pubDate>Thu, 16 Aug 2018 23:00:54 +0000</pubDate>
		<dc:creator><![CDATA[Clint Rutkas]]></dc:creator>
				<category><![CDATA[PC]]></category>
		<category><![CDATA[MSIX]]></category>
		<category><![CDATA[SDK]]></category>
		<category><![CDATA[Visual Studio]]></category>
		<category><![CDATA[Windows 10 SDK Preview Build]]></category>

		<guid isPermaLink="false">http://blogs.windows.com/buildingapps/?p=53961</guid>
		<description><![CDATA[<p>Today, we released a new Windows 10 Preview Build of the SDK to be used in conjunction with Windows 10 Insider Preview (Build 17733 or greater). The Preview SDK Build 17733 contains bug fixes and under development changes to the API surface area. The Preview SDK can be downloaded from developer section on Windows Insider. For feedback and [&#8230;]</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/16/windows-10-sdk-preview-build-17733-available-now/">Windows 10 SDK Preview Build 17733 available now!</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p>Today, we released a new Windows 10 Preview Build of the SDK to be used in conjunction with <a href="https://insider.windows.com/">Windows 10 Insider Preview</a> (Build <strong>17733 </strong>or greater). The Preview SDK Build <strong>17733 </strong>contains bug fixes and under development changes to the API surface area.</p>
<p>The Preview SDK can be downloaded from <a href="https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewSDK">developer section on Windows Insider</a>.</p>
<p>For feedback and updates to the known issues, please see the <a href="https://social.msdn.microsoft.com/Forums/en-US/home?forum=Win10SDKToolsIssues">developer forum.</a> For new developer feature requests, head over to our <a href="https://wpdev.uservoice.com/">Windows Platform UserVoice.</a></p>
<h1>Things to note:</h1>
<ul>
<li>This build works in conjunction with previously released SDKs and Visual Studio 2017. You can install this SDK and still also continue to submit your apps that target Windows 10 build 1803 or earlier to the Store.</li>
<li>The Windows SDK will now formally only be supported by Visual Studio 2017 and greater. You can download the Visual Studio 2017 <a href="https://www.visualstudio.com/downloads/">here</a>.</li>
<li>This build of the Windows SDK <strong>will</strong> only install on <a href="https://insider.windows.com/">Windows 10 Insider Preview</a> builds.</li>
<li>In order to assist with script access to the SDK, the ISO will also be able to be accessed through the following <a href="https://go.microsoft.com/fwlink/?prd=11966&amp;pver=1.0&amp;plcid=0x409&amp;clcid=0x409&amp;ar=Flight&amp;sar=Sdsurl&amp;o1=17733">link</a> once the static URL is published.</li>
</ul>
<h1>C++/WinRT Update for build 17709 and beyond:</h1>
<p>This update introduces many improvements and fixes for C++/WinRT. Notably, it introduces the ability to build C++/WinRT without any dependency on the Windows SDK. This isn’t particularly interesting to the OS developer, but even in the OS repo it provides benefits because it does not itself include any Windows headers. Thus, a developer will typically pull in fewer or no dependencies inadvertently. This also means a dramatic reduction in the number of macros that a C++/WinRT developer must guard against. Removing the dependency on the Windows headers means that C++/WinRT is more portable and standards compliant and furthers our efforts to make it a cross-compiler and cross-platform library. It also means that the C++/WinRT headers will never be mangled by macros. If you previously relied on C++/WinRT to include various Windows headers, you will now have to include them yourself. It&#8217;s always been good practice to always include any headers you depend on explicitly and not rely on another library to include them for you.</p>
<h2><strong>Highlights</strong></h2>
<p><strong>Support get_strong and get_weak to create delegates:</strong> This update allows a developer to use either get_strong or get_weak instead of a raw this pointer when creating a delegate pointing to a member function.</p>
<p><strong>Add async cancellation callback:</strong> The most frequently requested feature for C++/WinRT&#8217;s coroutine support has been the addition of a cancellation callback.</p>
<p><strong>Simplify the use of APIs expecting IBuffer parameters:</strong> Although most APIs prefer collections or arrays, enough APIs rely on IBuffer that it should be easier to use such APIs from C++. This update provides direct access to the data behind an IBuffer implementation using the same data naming convention used by the C++ standard library containers. This also avoids colliding with metadata names that conventionally begin with an uppercase letter.</p>
<p><strong>Conformance:</strong> Improved support for Clang and Visual C++’s stricter conformance modes.</p>
<p><strong>Improved code gen:</strong> Various improvements to reduce code size, improve inlining, and optimize factory caching.</p>
<p><strong>Remove unnecessary recursion:</strong> When the command line refers to a folder rather than a specific winmd, cppwinrt will no longer search recursively for winmd files. It causes performance problems in the OS build and can lead to usage errors that are hard to diagnose when developers inadvertently cause cppwinrt to consume more winmds than expected. The cppwinrt compiler also now handles duplicates more intelligently, making it more resilient to user error and poorly-formed winmd files.</p>
<p><strong>Declare both WINRT_CanUnloadNow and WINRT_GetActivationFactory in base.h:</strong> Callers don’t need to declare them directly. Their signatures have also changed, amounting to a breaking change. The declarations alleviate most of the pain of this change. The change is necessitated by the fact that C++/WinRT no longer depends on the Windows headers and this change removes the dependency on the types from the Windows headers.</p>
<p><strong>Harden smart pointers:</strong> The event revokers didn’t revoke when move-assigned a new value. This lead us to take a closer look at the smart pointer classes, where we noticed that they were not reliably handling self-assignment. This is rooted in the com_ptr class template that most of the others rely on. We fixed com_ptr and updated the event revokers to handle move semantics correctly to ensure that they revoke upon assignment. The handle class template has also been hardened by the removal of the implicit constructor that made it easy to write incorrect code. This also turned bugs in the OS into compiler errors fixed in this PR.</p>
<h2><strong>Breaking Changes</strong></h2>
<p>Support for non-WinRT interfaces is disabled by default. To enable, simply #include &lt;unknwn.h&gt; before any C++/WinRT headers.</p>
<p>winrt::get_abi(winrt::hstring) now returns void* instead of HSTRING. Code requiring the HSTRING ABI can simply use a static_cast.</p>
<p>winrt::put_abi(winrt::hstring) returns void** instead of HSTRING*. Code requiring the HSTRING ABI can simply use a reinterpret_cast.</p>
<p>HRESULT is now projected as winrt::hresult. Code requiring an HRESULT can simply static_cast if you need to do type checking or support type traits, but it is otherwise convertible as long as &lt;unknwn.h&gt; is included first.</p>
<p>GUID is now projected as winrt::guid. Code implementing APIs with GUID parameters must use winrt::guid instead, but it is otherwise convertible as long as &lt;unknwn.h&gt; is included first.</p>
<p>The signatures of WINRT_CanUnloadNow and WINRT_GetActivationFactory has changed. Code must not declare these functions at all and instead include winrt/base.h to include their declarations.</p>
<p>The winrt::handle constructor is now explicit. Code assigning a raw handle value must call the attach method instead.</p>
<p>winrt::clock::from_FILETIME has been deprecated. Code should use winrt::clock::from_file_time instead.</p>
<h1>What&#8217;s New:</h1>
<h2><strong>MSIX Support</strong></h2>
<p>It’s finally here! You can now package your applications as MSIX. These applications can be installed and run on any device with <strong>17682</strong> build or later.</p>
<p>To package your application with MSIX, use the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh446767(v=vs.85).aspx">MakeAppx tool</a>. To install the application – just click on the MSIX file. To learn more about MSIX, watch the introductory video here: <a href="https://channel9.msdn.com/events/Build/2018/BRK2432?term=msix%20inside%20and%20out">link</a></p>
<p>Feedback and comments are welcome on our MSIX community: <a href="http://aka.ms/MSIXCommunity">http://aka.ms/MSIXCommunity</a></p>
<p>MSIX is not currently supported by the App Certification Kit nor the Microsoft Store at this time.</p>
<h2><strong>MC.EXE</strong></h2>
<p>We’ve made some important changes to the C/C++ ETW code generation of mc.exe (Message Compiler):</p>
<p>The “-mof” parameter is deprecated. This parameter instructs MC.exe to generate ETW code that is compatible with Windows XP and earlier. Support for the “-mof” parameter will be removed in a future version of mc.exe.</p>
<p>As long as the “-mof” parameter is not used, the generated C/C++ header is now compatible with both kernel-mode and user-mode, regardless of whether “-km” or “-um” was specified on the command line. The header will use the _ETW_KM_ macro to automatically determine whether it is being compiled for kernel-mode or user-mode and will call the appropriate ETW APIs for each mode.</p>
<ul>
<li>The only remaining difference between “-km” and “-um” is that the EventWrite[EventName] macros generated with “-km” have an Activity ID parameter while the EventWrite[EventName] macros generated with “-um” do not have an Activity ID parameter.</li>
</ul>
<p>The EventWrite[EventName] macros now default to calling EventWriteTransfer (user mode) or EtwWriteTransfer (kernel mode). Previously, the EventWrite[EventName] macros defaulted to calling EventWrite (user mode) or EtwWrite (kernel mode).</p>
<ul>
<li>The generated header now supports several customization macros. For example, you can set the MCGEN_EVENTWRITETRANSFER macro if you need the generated macros to call something other than EventWriteTransfer.</li>
<li>The manifest supports new attributes.
<ul>
<li>Event “name”: non-localized event name.</li>
<li>Event “attributes”: additional key-value metadata for an event such as filename, line number, component name, function name.</li>
<li>Event “tags”: 28-bit value with user-defined semantics (per-event).</li>
<li>Field “tags”: 28-bit value with user-defined semantics (per-field – can be applied to “data” or “struct” elements).</li>
</ul>
</li>
<li>You can now define “provider traits” in the manifest (e.g. provider group). If provider traits are used in the manifest, the EventRegister[ProviderName] macro will automatically register them.</li>
<li>MC will now report an error if a localized message file is missing a string. (Previously MC would silently generate a corrupt message resource).</li>
<li>MC can now generate Unicode (utf-8 or utf-16) output with the “-cp utf-8” or “-cp utf-16” parameters.</li>
</ul>
<h1>Known Issues:</h1>
<p>The SDK headers are generated with types in the “ABI” namespace. This is done to avoid conflicts with C++/CX and C++/WinRT clients that need to consume types directly at the ABI layer[1]. By default, types emitted by MIDL are *<strong>not</strong>* put in the ABI namespace, however this has the potential to introduce conflicts from teams attempting to consume ABI types from Windows WinRT MIDL generated headers and non-Windows WinRT MIDL generated headers (this is especially challenging if the non-Windows header references Windows types).</p>
<p>To ensure that developers have a consistent view of the WinRT API surface, validation has been added to the generated headers to ensure that the ABI prefix is consistent between the Windows headers and user generated headers. If you encounter an error like:</p>
<p>5&gt;c:\program files (x86)\windows kits\10\include\10.0.17687.0\winrt\windows.foundation.h(83): error C2220: warning treated as error &#8211; no &#8216;object&#8217; file generated</p>
<p>5&gt;c:\program files (x86)\windows kits\10\include\10.0.17687.0\winrt\windows.foundation.h(83): warning C4005: &#8216;CHECK_NS_PREFIX_STATE&#8217;: macro redefinition</p>
<p>5&gt;g:\&lt;PATH TO YOUR HEADER HERE&gt;(41): note: see previous definition of &#8216;CHECK_NS_PREFIX_STATE&#8217;</p>
<p>It means that some of your MIDL generated headers are inconsistent with the system generated headers.</p>
<p><strong>There are two ways to fix this:</strong></p>
<ul>
<li><strong>Preferred:</strong> Compile your IDL file with the /ns_prefix MIDL command line switch. This will cause all your types to be moved to the ABI namespace consistent with the Windows headers. This may require code changes in your code however.</li>
<li><strong>Alternate:</strong> Add #define DISABLE_NS_PREFIX_CHECKS before including the Windows headers. This will suppress the validation.</li>
</ul>
<h1>API Updates, Additions and Removals</h1>
<p>When targeting new APIs, consider writing your app to be adaptive in order to run correctly on the widest number of Windows 10 devices. Please see <a href="https://blogs.windows.com/buildingapps/2015/09/15/dynamically-detecting-features-with-api-contracts-10-by-10/#HdHAk5RVtCg6bW4O.97">Dynamically detecting features with API contracts (10 by 10)</a> for more information.</p>
<p>The following APIs have been added to the platform since the release of 17134. The APIs listed below have been removed.</p>
<h2>Additions:</h2>
<pre class="brush: csharp; title: ; notranslate">
 
namespace Windows.AI.MachineLearning {
  public interface ILearningModelFeatureDescriptor
  public interface ILearningModelFeatureValue
  public interface ILearningModelOperatorProvider
  public sealed class ImageFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class ImageFeatureValue : ILearningModelFeatureValue
  public interface ITensor : ILearningModelFeatureValue
  public sealed class LearningModel : IClosable
  public sealed class LearningModelBinding : IIterable&lt;IKeyValuePair&lt;string, object&gt;&gt;, IMapView&lt;string, object&gt;
  public sealed class LearningModelDevice
  public enum LearningModelDeviceKind
  public sealed class LearningModelEvaluationResult
  public enum LearningModelFeatureKind
  public sealed class LearningModelSession : IClosable
  public struct MachineLearningContract
  public sealed class MapFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class SequenceFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class TensorBoolean : ILearningModelFeatureValue, ITensor
  public sealed class TensorDouble : ILearningModelFeatureValue, ITensor
  public sealed class TensorFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class TensorFloat : ILearningModelFeatureValue, ITensor
  public sealed class TensorFloat16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt32Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt64Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt8Bit : ILearningModelFeatureValue, ITensor
  public enum TensorKind
  public sealed class TensorString : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt32Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt64Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt8Bit : ILearningModelFeatureValue, ITensor
}
namespace Windows.ApplicationModel {
  public sealed class AppInstallerInfo
  public sealed class LimitedAccessFeatureRequestResult
  public static class LimitedAccessFeatures
  public enum LimitedAccessFeatureStatus
  public sealed class Package {
    IAsyncOperation&lt;PackageUpdateAvailabilityResult&gt; CheckUpdateAvailabilityAsync();
    AppInstallerInfo GetAppInstallerInfo();
  }
  public enum PackageUpdateAvailability
  public sealed class PackageUpdateAvailabilityResult
}
namespace Windows.ApplicationModel.Calls {
  public sealed class VoipCallCoordinator {
    IAsyncOperation&lt;VoipPhoneCallResourceReservationStatus&gt; ReserveCallResourcesAsync();
  }
}
namespace Windows.ApplicationModel.Chat {
  public static class ChatCapabilitiesManager {
    public static IAsyncOperation&lt;ChatCapabilities&gt; GetCachedCapabilitiesAsync(string address, string transportId);
    public static IAsyncOperation&lt;ChatCapabilities&gt; GetCapabilitiesFromNetworkAsync(string address, string transportId);
  }
  public static class RcsManager {
    public static event EventHandler&lt;object&gt; TransportListChanged;
  }
}
namespace Windows.ApplicationModel.DataTransfer {
  public static class Clipboard {
    public static event EventHandler&lt;ClipboardHistoryChangedEventArgs&gt; HistoryChanged;
    public static event EventHandler&lt;object&gt; HistoryEnabledChanged;
    public static event EventHandler&lt;object&gt; RoamingEnabledChanged;
    public static bool ClearHistory();
    public static bool DeleteItemFromHistory(ClipboardHistoryItem item);
    public static IAsyncOperation&lt;ClipboardHistoryItemsResult&gt; GetHistoryItemsAsync();
    public static bool IsHistoryEnabled();
    public static bool IsRoamingEnabled();
    public static bool SetContentWithOptions(DataPackage content, ClipboardContentOptions options);
    public static SetHistoryItemAsContentStatus SetHistoryItemAsContent(ClipboardHistoryItem item);
  }
  public sealed class ClipboardContentOptions
  public sealed class ClipboardHistoryChangedEventArgs
  public sealed class ClipboardHistoryItem
  public sealed class ClipboardHistoryItemsResult
  public enum ClipboardHistoryItemsResultStatus
  public sealed class DataPackagePropertySetView : IIterable&lt;IKeyValuePair&lt;string, object&gt;&gt;, IMapView&lt;string, object&gt; {
    bool IsFromRoamingClipboard { get; }
    string SourceDisplayName { get; }
  }
  public enum SetHistoryItemAsContentStatus
}
namespace Windows.ApplicationModel.Store.Preview {
  public enum DeliveryOptimizationDownloadMode
  public enum DeliveryOptimizationDownloadModeSource
  public sealed class DeliveryOptimizationSettings
  public static class StoreConfiguration {
    public static bool IsPinToDesktopSupported();
    public static bool IsPinToStartSupported();
    public static bool IsPinToTaskbarSupported();
    public static void PinToDesktop(string appPackageFamilyName);
    public static void PinToDesktopForUser(User user, string appPackageFamilyName);
  }
}
namespace Windows.ApplicationModel.Store.Preview.InstallControl {
  public enum AppInstallationToastNotificationMode
  public sealed class AppInstallItem {
    AppInstallationToastNotificationMode CompletedInstallToastNotificationMode { get; set; }
    AppInstallationToastNotificationMode InstallInProgressToastNotificationMode { get; set; }
    bool PinToDesktopAfterInstall { get; set; }
    bool PinToStartAfterInstall { get; set; }
    bool PinToTaskbarAfterInstall { get; set; }
  }
  public sealed class AppInstallManager {
    bool CanInstallForAllUsers { get; }
  }
  public sealed class AppInstallOptions {
    string CampaignId { get; set; }
    AppInstallationToastNotificationMode CompletedInstallToastNotificationMode { get; set; }
    string ExtendedCampaignId { get; set; }
    bool InstallForAllUsers { get; set; }
    AppInstallationToastNotificationMode InstallInProgressToastNotificationMode { get; set; }
    bool PinToDesktopAfterInstall { get; set; }
    bool PinToStartAfterInstall { get; set; }
    bool PinToTaskbarAfterInstall { get; set; }
    bool StageButDoNotInstall { get; set; }
  }
  public sealed class AppUpdateOptions {
    bool AutomaticallyDownloadAndInstallUpdateIfFound { get; set; }
  }
}
namespace Windows.ApplicationModel.UserActivities {
  public sealed class UserActivity {
    bool IsRoamable { get; set; }
  }
}
namespace Windows.Data.Text {
  public sealed class TextPredictionGenerator {
    CoreTextInputScope InputScope { get; set; }
    IAsyncOperation&lt;IVectorView&lt;string&gt;&gt; GetCandidatesAsync(string input, uint maxCandidates, TextPredictionOptions predictionOptions, IIterable&lt;string&gt; previousStrings);
    IAsyncOperation&lt;IVectorView&lt;string&gt;&gt; GetNextWordCandidatesAsync(uint maxCandidates, IIterable&lt;string&gt; previousStrings);
  }
  public enum TextPredictionOptions : uint
}
namespace Windows.Devices.Display.Core {
  public sealed class DisplayAdapter
  public enum DisplayBitsPerChannel : uint
  public sealed class DisplayDevice
  public enum DisplayDeviceCapability
  public sealed class DisplayFence
  public sealed class DisplayManager : IClosable
  public sealed class DisplayManagerChangedEventArgs
  public sealed class DisplayManagerDisabledEventArgs
  public sealed class DisplayManagerEnabledEventArgs
  public enum DisplayManagerOptions : uint
  public sealed class DisplayManagerPathsFailedOrInvalidatedEventArgs
  public enum DisplayManagerResult
  public sealed class DisplayManagerResultWithState
  public sealed class DisplayModeInfo
  public enum DisplayModeQueryOptions : uint
  public sealed class DisplayPath
  public enum DisplayPathScaling
  public enum DisplayPathStatus
  public struct DisplayPresentationRate
  public sealed class DisplayPrimaryDescription
  public enum DisplayRotation
  public sealed class DisplayScanout
  public sealed class DisplaySource
  public sealed class DisplayState
  public enum DisplayStateApplyOptions : uint
  public enum DisplayStateFunctionalizeOptions : uint
  public sealed class DisplayStateOperationResult
  public enum DisplayStateOperationStatus
  public sealed class DisplaySurface
  public sealed class DisplayTarget
  public enum DisplayTargetPersistence
  public sealed class DisplayTask
  public sealed class DisplayTaskPool
  public enum DisplayTaskSignalKind
  public sealed class DisplayView
  public sealed class DisplayWireFormat
  public enum DisplayWireFormatColorSpace
  public enum DisplayWireFormatEotf
  public enum DisplayWireFormatHdrMetadata
  public enum DisplayWireFormatPixelEncoding
}
namespace Windows.Devices.Enumeration {
  public enum DeviceInformationKind {
    DevicePanel = 8,
  }
  public sealed class DeviceInformationPairing {
    public static bool TryRegisterForAllInboundPairingRequestsWithProtectionLevel(DevicePairingKinds pairingKindsSupported, DevicePairingProtectionLevel minProtectionLevel);
  }
}
namespace Windows.Devices.Enumeration.Pnp {
  public enum PnpObjectType {
    DevicePanel = 8,
  }
}
namespace Windows.Devices.Lights {
  public sealed class LampArray
  public enum LampArrayKind
  public sealed class LampInfo
  public enum LampPurposes : uint
}
namespace Windows.Devices.Lights.Effects {
  public interface ILampArrayEffect
  public sealed class LampArrayBitmapEffect : ILampArrayEffect
  public sealed class LampArrayBitmapRequestedEventArgs
  public sealed class LampArrayBlinkEffect : ILampArrayEffect
  public sealed class LampArrayColorRampEffect : ILampArrayEffect
  public sealed class LampArrayCustomEffect : ILampArrayEffect
  public enum LampArrayEffectCompletionBehavior
  public sealed class LampArrayEffectPlaylist : IIterable&lt;ILampArrayEffect&gt;, IVectorView&lt;ILampArrayEffect&gt;
  public enum LampArrayEffectStartMode
  public enum LampArrayRepetitionMode
  public sealed class LampArraySolidEffect : ILampArrayEffect
  public sealed class LampArrayUpdateRequestedEventArgs
}
namespace Windows.Devices.PointOfService {
  public sealed class BarcodeScannerCapabilities {
    bool IsVideoPreviewSupported { get; }
  }
  public sealed class ClaimedBarcodeScanner : IClosable {
    event TypedEventHandler&lt;ClaimedBarcodeScanner, ClaimedBarcodeScannerClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedBarcodeScannerClosedEventArgs
  public sealed class ClaimedCashDrawer : IClosable {
    event TypedEventHandler&lt;ClaimedCashDrawer, ClaimedCashDrawerClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedCashDrawerClosedEventArgs
  public sealed class ClaimedLineDisplay : IClosable {
    event TypedEventHandler&lt;ClaimedLineDisplay, ClaimedLineDisplayClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedLineDisplayClosedEventArgs
  public sealed class ClaimedMagneticStripeReader : IClosable {
    event TypedEventHandler&lt;ClaimedMagneticStripeReader, ClaimedMagneticStripeReaderClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedMagneticStripeReaderClosedEventArgs
  public sealed class ClaimedPosPrinter : IClosable {
    event TypedEventHandler&lt;ClaimedPosPrinter, ClaimedPosPrinterClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedPosPrinterClosedEventArgs
}
namespace Windows.Devices.PointOfService.Provider {
  public sealed class BarcodeScannerDisableScannerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerEnableScannerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerFrameReader : IClosable
  public sealed class BarcodeScannerFrameReaderFrameArrivedEventArgs
  public sealed class BarcodeScannerGetSymbologyAttributesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerHideVideoPreviewRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerProviderConnection : IClosable {
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync();
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync(BitmapPixelFormat preferredFormat);
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync(BitmapPixelFormat preferredFormat, BitmapSize preferredSize);
  }
  public sealed class BarcodeScannerSetActiveSymbologiesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerSetSymbologyAttributesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerStartSoftwareTriggerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerStopSoftwareTriggerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerVideoFrame : IClosable
}
namespace Windows.Devices.Sensors {
  public sealed class HingeAngleReading
  public sealed class HingeAngleSensor
  public sealed class HingeAngleSensorReadingChangedEventArgs
  public sealed class SimpleOrientationSensor {
    public static IAsyncOperation&lt;SimpleOrientationSensor&gt; FromIdAsync(string deviceId);
    public static string GetDeviceSelector();
  }
}
namespace Windows.Devices.SmartCards {
 public static class KnownSmartCardAppletIds
  public sealed class SmartCardAppletIdGroup {
    string Description { get; set; }
    IRandomAccessStreamReference Logo { get; set; }
    ValueSet Properties { get; }
    bool SecureUserAuthenticationRequired { get; set; }
  }
  public sealed class SmartCardAppletIdGroupRegistration {
    string SmartCardReaderId { get; }
    IAsyncAction SetPropertiesAsync(ValueSet props);
  }
}
namespace Windows.Devices.WiFi {
  public enum WiFiPhyKind {
    HE = 10,
  }
}
namespace Windows.Foundation {
  public static class GuidHelper
}
namespace Windows.Globalization {
  public static class CurrencyIdentifiers {
    public static string MRU { get; }
    public static string SSP { get; }
    public static string STN { get; }
    public static string VES { get; }
  }
}
namespace Windows.Graphics.Capture {
  public sealed class Direct3D11CaptureFramePool : IClosable {
    public static Direct3D11CaptureFramePool CreateFreeThreaded(IDirect3DDevice device, DirectXPixelFormat pixelFormat, int numberOfBuffers, SizeInt32 size);
  }
  public sealed class GraphicsCaptureItem {
    public static GraphicsCaptureItem CreateFromVisual(Visual visual);
  }
}
namespace Windows.Graphics.Display.Core {
  public enum HdmiDisplayHdrOption {
    DolbyVisionLowLatency = 3,
  }
  public sealed class HdmiDisplayMode {
    bool IsDolbyVisionLowLatencySupported { get; }
  }
}
namespace Windows.Graphics.Holographic {
  public sealed class HolographicCamera {
    bool IsHardwareContentProtectionEnabled { get; set; }
    bool IsHardwareContentProtectionSupported { get; }
  }
  public sealed class HolographicQuadLayerUpdateParameters {
    bool CanAcquireWithHardwareProtection { get; }
    IDirect3DSurface AcquireBufferToUpdateContentWithHardwareProtection();
  }
}
namespace Windows.Graphics.Imaging {
  public sealed class BitmapDecoder : IBitmapFrame, IBitmapFrameWithSoftwareBitmap {
    public static Guid HeifDecoderId { get; }
    public static Guid WebpDecoderId { get; }
  }
  public sealed class BitmapEncoder {
    public static Guid HeifEncoderId { get; }
  }
}
namespace Windows.Management.Deployment {
  public enum DeploymentOptions : uint {
    ForceUpdateFromAnyVersion = (uint)262144,
  }
  public sealed class PackageManager {
    IAsyncOperationWithProgress&lt;DeploymentResult, DeploymentProgress&gt; DeprovisionPackageForAllUsersAsync(string packageFamilyName);
  }
  public enum RemovalOptions : uint {
    RemoveForAllUsers = (uint)524288,
  }
}
namespace Windows.Media.Audio {
  public sealed class CreateAudioDeviceInputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioDeviceOutputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioFileInputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioFileOutputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioGraphResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateMediaSourceAudioInputNodeResult {
    HResult ExtendedError { get; }
  }
  public enum MixedRealitySpatialAudioFormatPolicy
  public sealed class SetDefaultSpatialAudioFormatResult
  public enum SetDefaultSpatialAudioFormatStatus
  public sealed class SpatialAudioDeviceConfiguration
  public sealed class SpatialAudioFormatConfiguration
  public static class SpatialAudioFormatSubtype
}
namespace Windows.Media.Control {
  public sealed class CurrentSessionChangedEventArgs
  public sealed class GlobalSystemMediaTransportControlsSession
  public sealed class GlobalSystemMediaTransportControlsSessionManager
  public sealed class GlobalSystemMediaTransportControlsSessionMediaProperties
  public sealed class GlobalSystemMediaTransportControlsSessionPlaybackControls
  public sealed class GlobalSystemMediaTransportControlsSessionPlaybackInfo
  public enum GlobalSystemMediaTransportControlsSessionPlaybackStatus
  public sealed class GlobalSystemMediaTransportControlsSessionTimelineProperties
  public sealed class MediaPropertiesChangedEventArgs
  public sealed class PlaybackInfoChangedEventArgs
  public sealed class SessionsChangedEventArgs
  public sealed class TimelinePropertiesChangedEventArgs
}
namespace Windows.Media.Core {
  public sealed class MediaStreamSample {
    IDirect3DSurface Direct3D11Surface { get; }
    public static MediaStreamSample CreateFromDirect3D11Surface(IDirect3DSurface surface, TimeSpan timestamp);
  }
}
namespace Windows.Media.Devices.Core {
  public sealed class CameraIntrinsics {
    public CameraIntrinsics(Vector2 focalLength, Vector2 principalPoint, Vector3 radialDistortion, Vector2 tangentialDistortion, uint imageWidth, uint imageHeight);
  }
}
namespace Windows.Media.Import {
  public enum PhotoImportContentTypeFilter {
    ImagesAndVideosFromCameraRoll = 3,
  }
  public sealed class PhotoImportItem {
    string Path { get; }
  }
}
namespace Windows.Media.MediaProperties {
  public sealed class ImageEncodingProperties : IMediaEncodingProperties {
    public static ImageEncodingProperties CreateHeif();
  }
  public static class MediaEncodingSubtypes {
    public static string Heif { get; }
  }
}
namespace Windows.Media.Protection.PlayReady {
  public static class PlayReadyStatics {
    public static IReference&lt;DateTime&gt; HardwareDRMDisabledAtTime { get; }
    public static IReference&lt;DateTime&gt; HardwareDRMDisabledUntilTime { get; }
    public static void ResetHardwareDRMDisabled();
  }
}
namespace Windows.Media.Streaming.Adaptive {
  public enum AdaptiveMediaSourceResourceType {
    MediaSegmentIndex = 5,
  }
}
namespace Windows.Networking.BackgroundTransfer {
  public enum BackgroundTransferPriority {
    Low = 2,
  }
}
namespace Windows.Networking.Connectivity {
  public sealed class ConnectionProfile {
    bool CanDelete { get; }
    IAsyncOperation&lt;ConnectionProfileDeleteStatus&gt; TryDeleteAsync();
  }
  public enum ConnectionProfileDeleteStatus
}
namespace Windows.Networking.NetworkOperators {
  public enum ESimOperationStatus {
    CardGeneralFailure = 13,
    ConfirmationCodeMissing = 14,
    EidMismatch = 18,
    InvalidMatchingId = 15,
    NoCorrespondingRequest = 23,
    NoEligibleProfileForThisDevice = 16,
    OperationAborted = 17,
    OperationProhibitedByProfileClass = 21,
    ProfileNotAvailableForNewBinding = 19,
    ProfileNotPresent = 22,
    ProfileNotReleasedByOperator = 20,
  }
}
namespace Windows.Perception {
  public sealed class PerceptionTimestamp {
    TimeSpan SystemRelativeTargetTime { get; }
  }
  public static class PerceptionTimestampHelper {
    public static PerceptionTimestamp FromSystemRelativeTargetTime(TimeSpan targetTime);
  }
}
namespace Windows.Perception.Spatial {
  public sealed class SpatialAnchorExporter
  public enum SpatialAnchorExportPurpose
  public sealed class SpatialAnchorExportSufficiency
  public sealed class SpatialLocation {
    Vector3 AbsoluteAngularAccelerationAxisAngle { get; }
    Vector3 AbsoluteAngularVelocityAxisAngle { get; }
  }
}
namespace Windows.Perception.Spatial.Preview {
  public static class SpatialGraphInteropPreview
}
namespace Windows.Services.Cortana {
  public sealed class CortanaActionableInsights
  public sealed class CortanaActionableInsightsOptions
}
namespace Windows.Services.Store {
  public sealed class StoreAppLicense {
    bool IsDiscLicense { get; }
  }
  public sealed class StoreContext {
    IAsyncOperation&lt;StoreRateAndReviewResult&gt; RequestRateAndReviewAppAsync();
    IAsyncOperation&lt;IVectorView&lt;StoreQueueItem&gt;&gt; SetInstallOrderForAssociatedStoreQueueItemsAsync(IIterable&lt;StoreQueueItem&gt; items);
  }
  public sealed class StoreQueueItem {
    IAsyncAction CancelInstallAsync();
    IAsyncAction PauseInstallAsync();
    IAsyncAction ResumeInstallAsync();
  }
  public sealed class StoreRateAndReviewResult
  public enum StoreRateAndReviewStatus
}
namespace Windows.Storage.Provider {
  public enum StorageProviderHydrationPolicyModifier : uint {
    AutoDehydrationAllowed = (uint)4,
  }
  public sealed class StorageProviderSyncRootInfo {
    Guid ProviderId { get; set; }
  }
}
namespace Windows.System {
  public sealed class AppUriHandlerHost
  public sealed class AppUriHandlerRegistration
  public sealed class AppUriHandlerRegistrationManager
  public static class Launcher {
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathAsync(string path);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathAsync(string path, FolderLauncherOptions options);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathForUserAsync(User user, string path);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathForUserAsync(User user, string path, FolderLauncherOptions options);
  }
}
namespace Windows.System.Preview {
  public enum HingeState
  public sealed class TwoPanelHingedDevicePosturePreview
  public sealed class TwoPanelHingedDevicePosturePreviewReading
  public sealed class TwoPanelHingedDevicePosturePreviewReadingChangedEventArgs
}
namespace Windows.System.Profile {
  public enum SystemOutOfBoxExperienceState
 public static class SystemSetupInfo
  public static class WindowsIntegrityPolicy
}
namespace Windows.System.Profile.SystemManufacturers {
  public sealed class SystemSupportDeviceInfo
  public static class SystemSupportInfo {
    public static SystemSupportDeviceInfo LocalDeviceInfo { get; }
  }
}
namespace Windows.System.RemoteSystems {
  public sealed class RemoteSystem {
    IVectorView&lt;RemoteSystemApp&gt; Apps { get; }
  }
  public sealed class RemoteSystemApp
  public sealed class RemoteSystemAppRegistration
  public sealed class RemoteSystemConnectionInfo
  public sealed class RemoteSystemConnectionRequest {
    RemoteSystemApp RemoteSystemApp { get; }
    public static RemoteSystemConnectionRequest CreateForApp(RemoteSystemApp remoteSystemApp);
  }
  public sealed class RemoteSystemWebAccountFilter : IRemoteSystemFilter
}
namespace Windows.System.Update {
  public enum SystemUpdateAttentionRequiredReason
  public sealed class SystemUpdateItem
  public enum SystemUpdateItemState
  public sealed class SystemUpdateLastErrorInfo
  public static class SystemUpdateManager
  public enum SystemUpdateManagerState
  public enum SystemUpdateStartInstallAction
}
namespace Windows.System.UserProfile {
  public sealed class AssignedAccessSettings
}
namespace Windows.UI.Accessibility {
  public sealed class ScreenReaderPositionChangedEventArgs
  public sealed class ScreenReaderService
}
namespace Windows.UI.Composition {
  public enum AnimationPropertyAccessMode
  public sealed class AnimationPropertyInfo : CompositionObject
  public sealed class BooleanKeyFrameAnimation : KeyFrameAnimation
  public class CompositionAnimation : CompositionObject, ICompositionAnimationBase {
    void SetExpressionReferenceParameter(string parameterName, IAnimationObject source);
  }
  public enum CompositionBatchTypes : uint {
    AllAnimations = (uint)5,
    InfiniteAnimation = (uint)4,
  }
  public sealed class CompositionGeometricClip : CompositionClip
  public class CompositionGradientBrush : CompositionBrush {
    CompositionMappingMode MappingMode { get; set; }
  }
  public enum CompositionMappingMode
  public class CompositionObject : IAnimationObject, IClosable {
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    public static void StartAnimationGroupWithIAnimationObject(IAnimationObject target, ICompositionAnimationBase animation);
    public static void StartAnimationWithIAnimationObject(IAnimationObject target, string propertyName, CompositionAnimation animation);
  }
  public sealed class Compositor : IClosable {
    BooleanKeyFrameAnimation CreateBooleanKeyFrameAnimation();
    CompositionGeometricClip CreateGeometricClip();
    CompositionGeometricClip CreateGeometricClip(CompositionGeometry geometry);
    RedirectVisual CreateRedirectVisual();
    RedirectVisual CreateRedirectVisual(Visual source);
  }
  public interface IAnimationObject
  public sealed class RedirectVisual : ContainerVisual
}
namespace Windows.UI.Composition.Interactions {
  public sealed class InteractionSourceConfiguration : CompositionObject
  public enum InteractionSourceRedirectionMode
  public sealed class InteractionTracker : CompositionObject {
    bool IsInertiaFromImpulse { get; }
    int TryUpdatePosition(Vector3 value, InteractionTrackerClampingOption option);
    int TryUpdatePositionBy(Vector3 amount, InteractionTrackerClampingOption option);
  }
  public enum InteractionTrackerClampingOption
  public sealed class InteractionTrackerInertiaStateEnteredArgs {
    bool IsInertiaFromImpulse { get; }
  }
  public class VisualInteractionSource : CompositionObject, ICompositionInteractionSource {
    InteractionSourceConfiguration PointerWheelConfig { get; }
  }
}
namespace Windows.UI.Input.Inking {
  public enum HandwritingLineHeight
  public sealed class PenAndInkSettings
  public enum PenHandedness
}
namespace Windows.UI.Input.Inking.Preview {
  public sealed class PalmRejectionDelayZonePreview : IClosable
}
namespace Windows.UI.Notifications {
  public sealed class ScheduledToastNotificationShowingEventArgs
  public sealed class ToastNotifier {
    event TypedEventHandler&lt;ToastNotifier, ScheduledToastNotificationShowingEventArgs&gt; ScheduledToastNotificationShowing;
  }
}
namespace Windows.UI.Shell {
  public enum SecurityAppKind
  public sealed class SecurityAppManager
  public struct SecurityAppManagerContract
  public enum SecurityAppState
  public enum SecurityAppSubstatus
  public sealed class TaskbarManager {
    IAsyncOperation&lt;bool&gt; IsSecondaryTilePinnedAsync(string tileId);
    IAsyncOperation&lt;bool&gt; RequestPinSecondaryTileAsync(SecondaryTile secondaryTile);
    IAsyncOperation&lt;bool&gt; TryUnpinSecondaryTileAsync(string tileId);
  }
}
namespace Windows.UI.StartScreen {
  public sealed class StartScreenManager {
    IAsyncOperation&lt;bool&gt; ContainsSecondaryTileAsync(string tileId);
    IAsyncOperation&lt;bool&gt; TryRemoveSecondaryTileAsync(string tileId);
  }
}
namespace Windows.UI.Text {
  public sealed class RichEditTextDocument : ITextDocument {
    void ClearUndoRedoHistory();
  }
}
namespace Windows.UI.Text.Core {
  public sealed class CoreTextLayoutRequest {
    CoreTextLayoutBounds LayoutBoundsVisualPixels { get; }
  }
}
namespace Windows.UI.ViewManagement {
  public enum ApplicationViewWindowingMode {
    CompactOverlay = 3,
    Maximized = 4,
  }
}
namespace Windows.UI.ViewManagement.Core {
  public sealed class CoreInputView {
    bool TryHide();
    bool TryShow();
    bool TryShow(CoreInputViewKind type);
  }
  public enum CoreInputViewKind
}
namespace Windows.UI.WebUI {
  public sealed class BackgroundActivatedEventArgs : IBackgroundActivatedEventArgs
  public delegate void BackgroundActivatedEventHandler(object sender, IBackgroundActivatedEventArgs eventArgs);
  public sealed class NewWebUIViewCreatedEventArgs
  public static class WebUIApplication {
    public static event BackgroundActivatedEventHandler BackgroundActivated;
    public static event EventHandler&lt;NewWebUIViewCreatedEventArgs&gt; NewWebUIViewCreated;
  }
  public sealed class WebUIView : IWebViewControl, IWebViewControl2
}
namespace Windows.UI.Xaml {
  public class BrushTransition
  public class ColorPaletteResources : ResourceDictionary
  public class DataTemplate : FrameworkTemplate, IElementFactory {
    UIElement GetElement(ElementFactoryGetArgs args);
    void RecycleElement(ElementFactoryRecycleArgs args);
  }
  public sealed class DebugSettings {
    bool FailFastOnErrors { get; set; }
  }
  public sealed class EffectiveViewportChangedEventArgs
  public class ElementFactoryGetArgs
  public class ElementFactoryRecycleArgs
  public class FrameworkElement : UIElement {
    bool IsLoaded { get; }
    event TypedEventHandler&lt;FrameworkElement, EffectiveViewportChangedEventArgs&gt; EffectiveViewportChanged;
    void InvalidateViewport();
  }
  public interface IElementFactory
  public class ScalarTransition
  public class UIElement : DependencyObject, IAnimationObject {
    bool CanBeScrollAnchor { get; set; }
    public static DependencyProperty CanBeScrollAnchorProperty { get; }
    Vector3 CenterPoint { get; set; }
    ScalarTransition OpacityTransition { get; set; }
    float Rotation { get; set; }
    Vector3 RotationAxis { get; set; }
    ScalarTransition RotationTransition { get; set; }
    Vector3 Scale { get; set; }
    Vector3Transition ScaleTransition { get; set; }
    Matrix4x4 TransformMatrix { get; set; }
    Vector3 Translation { get; set; }
    Vector3Transition TranslationTransition { get; set; }
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    virtual void PopulatePropertyInfoOverride(string propertyName, AnimationPropertyInfo animationPropertyInfo);
    void StartAnimation(ICompositionAnimationBase animation);
    void StopAnimation(ICompositionAnimationBase animation);
  }
  public class Vector3Transition
  public enum Vector3TransitionComponents : uint
}
namespace Windows.UI.Xaml.Automation {
  public sealed class AutomationElementIdentifiers {
    public static AutomationProperty IsDialogProperty { get; }
  }
  public sealed class AutomationProperties {
    public static DependencyProperty IsDialogProperty { get; }
    public static bool GetIsDialog(DependencyObject element);
    public static void SetIsDialog(DependencyObject element, bool value);
  }
}
namespace Windows.UI.Xaml.Automation.Peers {
  public class AppBarButtonAutomationPeer : ButtonAutomationPeer, IExpandCollapseProvider {
    ExpandCollapseState ExpandCollapseState { get; }
    void Collapse();
    void Expand();
  }
  public class AutomationPeer : DependencyObject {
    bool IsDialog();
    virtual bool IsDialogCore();
  }
  public class MenuBarAutomationPeer : FrameworkElementAutomationPeer
  public class MenuBarItemAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IInvokeProvider
}
namespace Windows.UI.Xaml.Controls {
  public sealed class AnchorRequestedEventArgs
  public class AppBarElementContainer : ContentControl, ICommandBarElement, ICommandBarElement2
  public sealed class AutoSuggestBox : ItemsControl {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
  }
  public enum BackgroundSizing
  public sealed class Border : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    BrushTransition BackgroundTransition { get; set; }
  }
  public class CalendarDatePicker : Control {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
  }
  public class ComboBox : Selector {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    bool IsEditable { get; set; }
    public static DependencyProperty IsEditableProperty { get; }
    string Text { get; set; }
    Style TextBoxStyle { get; set; }
    public static DependencyProperty TextBoxStyleProperty { get; }
    public static DependencyProperty TextProperty { get; }
    event TypedEventHandler&lt;ComboBox, ComboBoxTextSubmittedEventArgs&gt; TextSubmitted;
  }
  public sealed class ComboBoxTextSubmittedEventArgs
  public class CommandBarFlyout : FlyoutBase
  public class ContentPresenter : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    BrushTransition BackgroundTransition { get; set; }
  }
  public class Control : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    CornerRadius CornerRadius { get; set; }
    public static DependencyProperty CornerRadiusProperty { get; }
  }
  public class DataTemplateSelector : IElementFactory {
    UIElement GetElement(ElementFactoryGetArgs args);
    void RecycleElement(ElementFactoryRecycleArgs args);
  }
  public class DatePicker : Control {
    IReference&lt;DateTime&gt; SelectedDate { get; set; }
    public static DependencyProperty SelectedDateProperty { get; }
    event TypedEventHandler&lt;DatePicker, DatePickerSelectedValueChangedEventArgs&gt; SelectedDateChanged;
  }
  public sealed class DatePickerSelectedValueChangedEventArgs
  public class DropDownButton : Button
  public class DropDownButtonAutomationPeer : ButtonAutomationPeer, IExpandCollapseProvider
  public class Frame : ContentControl, INavigate {
    bool IsNavigationStackEnabled { get; set; }
    public static DependencyProperty IsNavigationStackEnabledProperty { get; }
    bool NavigateToType(TypeName sourcePageType, object parameter, FrameNavigationOptions navigationOptions);
  }
  public class Grid : Panel {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public class IconSourceElement : IconElement
  public sealed class InputPropertyAttribute : Attribute
  public interface IScrollAnchorProvider
  public class MenuBar : Control
  public class MenuBarItem : Control
  public class MenuBarItemFlyout : MenuFlyout
  public class NavigationView : ContentControl {
    UIElement ContentOverlay { get; set; }
    public static DependencyProperty ContentOverlayProperty { get; }
    bool IsPaneVisible { get; set; }
    public static DependencyProperty IsPaneVisibleProperty { get; }
    NavigationViewOverflowLabelMode OverflowLabelMode { get; set; }
    public static DependencyProperty OverflowLabelModeProperty { get; }
    UIElement PaneCustomContent { get; set; }
    public static DependencyProperty PaneCustomContentProperty { get; }
    NavigationViewPaneDisplayMode PaneDisplayMode { get; set; }
    public static DependencyProperty PaneDisplayModeProperty { get; }
    UIElement PaneHeader { get; set; }
    public static DependencyProperty PaneHeaderProperty { get; }
    NavigationViewSelectionFollowsFocus SelectionFollowsFocus { get; set; }
    public static DependencyProperty SelectionFollowsFocusProperty { get; }
    NavigationViewShoulderNavigationEnabled ShoulderNavigationEnabled { get; set; }
    public static DependencyProperty ShoulderNavigationEnabledProperty { get; }
    NavigationViewTemplateSettings TemplateSettings { get; }
    public static DependencyProperty TemplateSettingsProperty { get; }
  }
  public class NavigationViewItem : NavigationViewItemBase {
    bool SelectsOnInvoked { get; set; }
    public static DependencyProperty SelectsOnInvokedProperty { get; }
  }
  public sealed class NavigationViewItemInvokedEventArgs {
    NavigationViewItemBase InvokedItemContainer { get; }
    NavigationTransitionInfo RecommendedNavigationTransitionInfo { get; }
  }
  public enum NavigationViewOverflowLabelMode
  public enum NavigationViewPaneDisplayMode
  public sealed class NavigationViewSelectionChangedEventArgs {
    NavigationTransitionInfo RecommendedNavigationTransitionInfo { get; }
    NavigationViewItemBase SelectedItemContainer { get; }
  }
  public enum NavigationViewSelectionFollowsFocus
  public enum NavigationViewShoulderNavigationEnabled
  public class NavigationViewTemplateSettings : DependencyObject
  public class Panel : FrameworkElement {
    BrushTransition BackgroundTransition { get; set; }
  }
  public sealed class PasswordBox : Control {
    bool CanPasteClipboardContent { get; }
    public static DependencyProperty CanPasteClipboardContentProperty { get; }
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void PasteFromClipboard();
  }
  public class RelativePanel : Panel {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public class RichEditBox : Control {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase ProofingMenuFlyout { get; }
    public static DependencyProperty ProofingMenuFlyoutProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    RichEditTextDocument TextDocument { get; }
    event TypedEventHandler&lt;RichEditBox, RichEditBoxSelectionChangingEventArgs&gt; SelectionChanging;
  }
  public sealed class RichEditBoxSelectionChangingEventArgs
  public sealed class RichTextBlock : FrameworkElement {
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void CopySelectionToClipboard();
  }
  public sealed class ScrollContentPresenter : ContentPresenter {
    bool CanContentRenderOutsideBounds { get; set; }
    public static DependencyProperty CanContentRenderOutsideBoundsProperty { get; }
    bool SizesContentToTemplatedParent { get; set; }
    public static DependencyProperty SizesContentToTemplatedParentProperty { get; }
  }
  public sealed class ScrollViewer : ContentControl, IScrollAnchorProvider {
    bool CanContentRenderOutsideBounds { get; set; }
    public static DependencyProperty CanContentRenderOutsideBoundsProperty { get; }
    UIElement CurrentAnchor { get; }
    double HorizontalAnchorRatio { get; set; }
    public static DependencyProperty HorizontalAnchorRatioProperty { get; }
    bool ReduceViewportForCoreInputViewOcclusions { get; set; }
    public static DependencyProperty ReduceViewportForCoreInputViewOcclusionsProperty { get; }
    double VerticalAnchorRatio { get; set; }
    public static DependencyProperty VerticalAnchorRatioProperty { get; }
    event TypedEventHandler&lt;ScrollViewer, AnchorRequestedEventArgs&gt; AnchorRequested;
    public static bool GetCanContentRenderOutsideBounds(DependencyObject element);
    void RegisterAnchorCandidate(UIElement element);
    public static void SetCanContentRenderOutsideBounds(DependencyObject element, bool canContentRenderOutsideBounds);
    void UnregisterAnchorCandidate(UIElement element);
  }
  public class SplitButton : ContentControl
  public class SplitButtonAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IInvokeProvider
  public sealed class SplitButtonClickEventArgs
  public class StackPanel : Panel, IInsertionPanel, IScrollSnapPointsInfo {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public sealed class TextBlock : FrameworkElement {
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void CopySelectionToClipboard();
  }
  public class TextBox : Control {
    bool CanPasteClipboardContent { get; }
    public static DependencyProperty CanPasteClipboardContentProperty { get; }
    bool CanRedo { get; }
    public static DependencyProperty CanRedoProperty { get; }
    bool CanUndo { get; }
    public static DependencyProperty CanUndoProperty { get; }
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase ProofingMenuFlyout { get; }
    public static DependencyProperty ProofingMenuFlyoutProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    event TypedEventHandler&lt;TextBox, TextBoxSelectionChangingEventArgs&gt; SelectionChanging;
    void ClearUndoRedoHistory();
    void CopySelectionToClipboard();
    void CutSelectionToClipboard();
    void PasteFromClipboard();
    void Redo();
    void Undo();
  }
  public sealed class TextBoxSelectionChangingEventArgs
  public class TextCommandBarFlyout : CommandBarFlyout
  public class TimePicker : Control {
    IReference&lt;TimeSpan&gt; SelectedTime { get; set; }
    public static DependencyProperty SelectedTimeProperty { get; }
    event TypedEventHandler&lt;TimePicker, TimePickerSelectedValueChangedEventArgs&gt; SelectedTimeChanged;
  }
  public sealed class TimePickerSelectedValueChangedEventArgs
  public class ToggleSplitButton : SplitButton
  public class ToggleSplitButtonAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IToggleProvider
  public sealed class ToggleSplitButtonIsCheckedChangedEventArgs
  public class ToolTip : ContentControl {
    IReference&lt;Rect&gt; PlacementRect { get; set; }
    public static DependencyProperty PlacementRectProperty { get; }
  }
  public class TreeView : Control {
    bool CanDragItems { get; set; }
    public static DependencyProperty CanDragItemsProperty { get; }
    bool CanReorderItems { get; set; }
    public static DependencyProperty CanReorderItemsProperty { get; }
    Style ItemContainerStyle { get; set; }
    public static DependencyProperty ItemContainerStyleProperty { get; }
    StyleSelector ItemContainerStyleSelector { get; set; }
    public static DependencyProperty ItemContainerStyleSelectorProperty { get; }
    TransitionCollection ItemContainerTransitions { get; set; }
    public static DependencyProperty ItemContainerTransitionsProperty { get; }
    object ItemsSource { get; set; }
    public static DependencyProperty ItemsSourceProperty { get; }
    DataTemplate ItemTemplate { get; set; }
    public static DependencyProperty ItemTemplateProperty { get; }
    DataTemplateSelector ItemTemplateSelector { get; set; }
    public static DependencyProperty ItemTemplateSelectorProperty { get; }
    event TypedEventHandler&lt;TreeView, TreeViewDragItemsCompletedEventArgs&gt; DragItemsCompleted;
    event TypedEventHandler&lt;TreeView, TreeViewDragItemsStartingEventArgs&gt; DragItemsStarting;
    DependencyObject ContainerFromItem(object item);
    DependencyObject ContainerFromNode(TreeViewNode node);
    object ItemFromContainer(DependencyObject container);
    TreeViewNode NodeFromContainer(DependencyObject container);
  }
  public sealed class TreeViewCollapsedEventArgs {
    object Item { get; }
  }
  public sealed class TreeViewDragItemsCompletedEventArgs
  public sealed class TreeViewDragItemsStartingEventArgs
  public sealed class TreeViewExpandingEventArgs {
    object Item { get; }
  }
  public class TreeViewItem : ListViewItem {
    bool HasUnrealizedChildren { get; set; }
    public static DependencyProperty HasUnrealizedChildrenProperty { get; }
    object ItemsSource { get; set; }
    public static DependencyProperty ItemsSourceProperty { get; }
  }
  public class TwoPaneView : Control
  public enum TwoPaneViewMode
  public enum TwoPaneViewPriority
  public enum TwoPaneViewTallModeConfiguration
  public enum TwoPaneViewWideModeConfiguration
  public sealed class WebView : FrameworkElement {
    event TypedEventHandler&lt;WebView, WebViewWebResourceRequestedEventArgs&gt; WebResourceRequested;
  }
  public sealed class WebViewWebResourceRequestedEventArgs
}
namespace Windows.UI.Xaml.Controls.Maps {
  public enum MapTileAnimationState
  public sealed class MapTileBitmapRequestedEventArgs {
    int FrameIndex { get; }
  }
  public class MapTileSource : DependencyObject {
    MapTileAnimationState AnimationState { get; }
    public static DependencyProperty AnimationStateProperty { get; }
    bool AutoPlay { get; set; }
    public static DependencyProperty AutoPlayProperty { get; }
    int FrameCount { get; set; }
    public static DependencyProperty FrameCountProperty { get; }
    TimeSpan FrameDuration { get; set; }
    public static DependencyProperty FrameDurationProperty { get; }
    void Pause();
    void Play();
    void Stop();
  }
  public sealed class MapTileUriRequestedEventArgs {
    int FrameIndex { get; }
  }
}
namespace Windows.UI.Xaml.Controls.Primitives {
  public class CommandBarFlyoutCommandBar : CommandBar
  public sealed class CommandBarFlyoutCommandBarTemplateSettings : DependencyObject
  public class FlyoutBase : DependencyObject {
    bool AreOpenCloseAnimationsEnabled { get; set; }
    public static DependencyProperty AreOpenCloseAnimationsEnabledProperty { get; }
    bool InputDevicePrefersPrimaryCommands { get; }
    public static DependencyProperty InputDevicePrefersPrimaryCommandsProperty { get; }
    bool IsOpen { get; }
    public static DependencyProperty IsOpenProperty { get; }
    FlyoutShowMode ShowMode { get; set; }
    public static DependencyProperty ShowModeProperty { get; }
    public static DependencyProperty TargetProperty { get; }
    void ShowAt(DependencyObject placementTarget, FlyoutShowOptions showOptions);
  }
  public enum FlyoutPlacementMode {
    Auto = 13,
    BottomEdgeAlignedLeft = 7,
    BottomEdgeAlignedRight = 8,
    LeftEdgeAlignedBottom = 10,
    LeftEdgeAlignedTop = 9,
    RightEdgeAlignedBottom = 12,
    RightEdgeAlignedTop = 11,
    TopEdgeAlignedLeft = 5,
    TopEdgeAlignedRight = 6,
  }
  public enum FlyoutShowMode
  public class FlyoutShowOptions
  public class NavigationViewItemPresenter : ContentControl
}
namespace Windows.UI.Xaml.Core.Direct {
  public interface IXamlDirectObject
  public sealed class XamlDirect
  public struct XamlDirectContract
  public enum XamlEventIndex
  public enum XamlPropertyIndex
  public enum XamlTypeIndex
}
namespace Windows.UI.Xaml.Hosting {
  public class DesktopWindowXamlSource : IClosable
  public sealed class DesktopWindowXamlSourceGotFocusEventArgs
  public sealed class DesktopWindowXamlSourceTakeFocusRequestedEventArgs
  public sealed class WindowsXamlManager : IClosable
  public enum XamlSourceFocusNavigationReason
  public sealed class XamlSourceFocusNavigationRequest
  public sealed class XamlSourceFocusNavigationResult
}
namespace Windows.UI.Xaml.Input {
  public sealed class CanExecuteRequestedEventArgs
  public sealed class ExecuteRequestedEventArgs
  public sealed class FocusManager {
    public static event EventHandler&lt;GettingFocusEventArgs&gt; GettingFocus;
    public static event EventHandler&lt;FocusManagerGotFocusEventArgs&gt; GotFocus;
    public static event EventHandler&lt;LosingFocusEventArgs&gt; LosingFocus;
    public static event EventHandler&lt;FocusManagerLostFocusEventArgs&gt; LostFocus;
  }
  public sealed class FocusManagerGotFocusEventArgs
  public sealed class FocusManagerLostFocusEventArgs
  public sealed class GettingFocusEventArgs : RoutedEventArgs {
    Guid CorrelationId { get; }
  }
  public sealed class LosingFocusEventArgs : RoutedEventArgs {
    Guid CorrelationId { get; }
  }
  public class StandardUICommand : XamlUICommand
  public enum StandardUICommandKind
  public class XamlUICommand : DependencyObject, ICommand
}
namespace Windows.UI.Xaml.Markup {
  public sealed class FullXamlMetadataProviderAttribute : Attribute
  public interface IXamlBindScopeDiagnostics
  public interface IXamlType2 : IXamlType
}
namespace Windows.UI.Xaml.Media {
  public class Brush : DependencyObject, IAnimationObject {
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    virtual void PopulatePropertyInfoOverride(string propertyName, AnimationPropertyInfo animationPropertyInfo);
  }
}
namespace Windows.UI.Xaml.Media.Animation {
  public class BasicConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public sealed class ConnectedAnimation {
    ConnectedAnimationConfiguration Configuration { get; set; }
  }
  public class ConnectedAnimationConfiguration
  public class DirectConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public class GravityConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public enum SlideNavigationTransitionEffect
  public sealed class SlideNavigationTransitionInfo : NavigationTransitionInfo {
    SlideNavigationTransitionEffect Effect { get; set; }
    public static DependencyProperty EffectProperty { get; }
  }
}
namespace Windows.UI.Xaml.Navigation {
  public class FrameNavigationOptions
}
namespace Windows.Web.UI {
  public interface IWebViewControl2
  public sealed class WebViewControlNewWindowRequestedEventArgs {
    IWebViewControl NewWindow { get; set; }
    Deferral GetDeferral();
  }
  public enum WebViewControlPermissionType {
    ImmersiveView = 6,
  }
}
namespace Windows.Web.UI.Interop {
  public sealed class WebViewControl : IWebViewControl, IWebViewControl2 {
    event TypedEventHandler&lt;WebViewControl, object&gt; GotFocus;
    event TypedEventHandler&lt;WebViewControl, object&gt; LostFocus;
    void AddInitializeScript(string script);
  }
}

</pre>
<h2>Removals:</h2>
<pre class="brush: plain; title: ; notranslate">

namespace Windows.Gaming.UI {
  public sealed class GameMonitor
  public enum GameMonitoringPermission
}

</pre>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/16/windows-10-sdk-preview-build-17733-available-now/">Windows 10 SDK Preview Build 17733 available now!</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></content:encoded>
			<wfw:commentRss>https://blogs.windows.com/buildingapps/2018/08/16/windows-10-sdk-preview-build-17733-available-now/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Introducing Driver Module Framework</title>
		<link>https://blogs.windows.com/buildingapps/2018/08/15/introducing-driver-module-framework/</link>
		<comments>https://blogs.windows.com/buildingapps/2018/08/15/introducing-driver-module-framework/#comments</comments>
		<pubDate>Wed, 15 Aug 2018 17:00:44 +0000</pubDate>
		<dc:creator><![CDATA[Microsoft Devices Team]]></dc:creator>
				<category><![CDATA[PC]]></category>
		<category><![CDATA[DMF]]></category>
		<category><![CDATA[Driver Module Framework]]></category>
		<category><![CDATA[WDF]]></category>
		<category><![CDATA[Windows Driver Framework]]></category>

		<guid isPermaLink="false">http://blogs.windows.com/buildingapps/?p=53988</guid>
		<description><![CDATA[<p>The Microsoft Devices team is excited to announce the release of an open source framework for Windows driver developers — Driver Module Framework (DMF). With DMF, not only can you easily develop simple and structured Windows Driver Framework (WDF) drivers but also share code amongst your drivers. Background Over the years Surface organization developed many [&#8230;]</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/15/introducing-driver-module-framework/">Introducing Driver Module Framework</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p>The Microsoft Devices team is excited to announce the release of an open source framework for Windows driver developers — <strong>Driver Module Framework (DMF)</strong>. With DMF, not only can you easily develop simple and structured Windows Driver Framework (WDF) drivers but also share code amongst your drivers.</p>
<h1>Background</h1>
<p>Over the years Surface organization developed many products such as Pro, Studio, Laptop, Book with unique, innovative hardware capabilities. To light up these capabilities, we often needed to write drivers and firmware. Even though these products had commonalities in terms of how they interfaced with the hardware, individual product teams worked in isolation and built either their own drivers from scratch or copied based on their awareness of existing code and modified to suit their needs. This did help in meeting their immediate business priorities, but led to tremendous duplication of code and maintenance overhead. Developers with varied level of experience often created many divergent solutions to solve the same problem and the code lacked structure and quality.</p>
<p>About three years ago, the team decided to take a holistic look at drivers written for various Surface products and started an effort to structure code in a way that allows for maximum reuse of code with goals to improve the efficiency, serviceability, and scalability of teams to build new products.</p>
<p>We started by breaking down individual functionalities in drivers into a shareable code base. This iterative effort led to the creation of DMF: an extension to WDF that provides you with a library of new WDF Objects called DMF Modules. Modules allow interaction with one another, WDF, and hardware in a structured manner.</p>
<p>Today, all WDF drivers on the team are written by using DMF. Modules are well tested and can be reused or extended later to meet new requirements. Besides having the benefit of well-architected drivers, bug fixes are now efficient. A bug fix in a Module is automatically applied to all the drivers that were built using the Module.</p>
<p>As part of the open source effort, we have shared many Modules that provide solutions for commonly faced problems.</p>
<h1>Architecture of DMF</h1>
<p>Let’s start by looking at a typical design of WDF driver.</p>
<p><img class="aligncenter size-full wp-image-54003" src="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/b1c20e658a6821c199de0797cc5f7b97.png" alt="A typical design of a WDF driver." width="710" height="306" srcset="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/b1c20e658a6821c199de0797cc5f7b97.png 710w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/b1c20e658a6821c199de0797cc5f7b97-300x129.png 300w" sizes="(max-width: 710px) 100vw, 710px" /></p>
<p>In this design, the driver maintains state in a device context and the code is divided into units that access the device context and communicate among themselves. You, as the driver developer, are responsible for making sure that accesses to the device context are synchronized and strict locking hierarchy is adhered to when units communicate with each other to avoid corruption and deadlock. As WDF calls into the driver, you are also responsible for dispatching work to each of the units as needed. It is hard to know the flow of communication and keep access to the device context properly synchronized.</p>
<p>If you want to reuse for example FIFO code in another driver. You need to understand the complex interaction between the units before extracting the code and the fields used to store the state. Often times, that is error prone.</p>
<p>Now let’s improve the architecture by using DMF. Here the driver is built by using a client Module and several prebuilt generic utility Modules. We are going to refer to code that uses a Module as the client driver. Between WDF and individual Modules, there is a thin arbitration layer (DMF) to bind Modules and dispatch WDF events to each Module. Now, Modules communicate with each other and the client driver in a well-defined manner as shown by the arrows. Instead of all the Modules sharing the device context, each one uses its own context area to maintain its state.</p>
<p><img class="aligncenter wp-image-54006 size-full" src="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/d00df062d3353dd3f823249ec71536e5.png" alt="Key differences between a traditional WDF and DMF-based WDF driver." width="702" height="397" srcset="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/d00df062d3353dd3f823249ec71536e5.png 702w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/d00df062d3353dd3f823249ec71536e5-300x170.png 300w" sizes="(max-width: 702px) 100vw, 702px" /></p>
<p><strong>Here are some key differences between a traditional WDF and DMF-based WDF driver:</strong></p>
<ul>
<li>WDF communicates with DMF, while DMF communicates with the driver.</li>
<li>The device context (shown in green) exists independently in each Module and in the client driver-specific code. Each smaller device context holds only the elements that are needed for that Module. No Module can access another Module’s device context.</li>
<li>The WDF callbacks (shown in red) now exist independently in each Module and in the client-specific code. WDF calls into the client driver. DMF intercepts that call and dispatches it to each Module in the tree of instantiated Modules. Each Module handles each callback as it sees fit. Finally, DMF dispatches the callbacks to the client driver’s callbacks.</li>
<li>Finally, note the arrows. The arrows specifically show the flow among Modules and the client-specific code. In this example, client-specific code can only communicate with three Modules: ACPI, Button, and Stream. It cannot communicate with GPIO, FIFO, List, or Thread. ACPI cannot communicate with FIFO, etc. Even without looking at source code, we have a good idea of how data flows in this driver.</li>
</ul>
<p>To summarize, each Module is a self-contained single unit. It has its own code, context, and callbacks. This makes the code easy to reuse. Organizing drivers in this way solves many problems.</p>
<h1>Design of DMF Modules</h1>
<p>DMF follows design and interaction patterns of WDF. DMF does not replace WDF nor does it restrict the driver from using OS interfaces directly. DMF makes it easier for you to break down the tasks that a device driver must perform into smaller units. Then, those smaller, self-contained units that perform a single task can be written as Modules.</p>
<p>1. DMF Modules use interaction patterns consistent with existing WDF objects. Just like any WDF object, a DMF Module:</p>
<ul>
<li>Has a CONFIG structure, methods, and event callbacks.</li>
<li>Can be parented to other WDF objects for life time management.</li>
</ul>
<p>2. Modules within a client driver are organized into a tree structure that is maintained by the core of DMF. The core is responsible for creating, opening, closing, and destroying Modules. In turn each Module is responsible allocating and freeing its own resources.</p>
<p>3. Modules that are siblings of each other cannot communicate directly. Only Modules in a parent-child relationship can communicate with each other; only parent Modules can communicate with their children Modules (with the exception of callbacks).</p>
<p>4. Modules can be extended to meet new requirements, or a new Module can be created by combining multiple Modules.</p>
<p>5. Module design is analogous to a class in an object-oriented programming pattern. If you are familiar with the Universal Extensible Firmware Interface (UEFI) Driver Execution Environment (DXE), you will find similarity with Modules.)</p>
<table width="526">
<tbody>
<tr>
<td width="172">
<h2><strong>DMF Module </strong></h2>
</td>
<td width="354">
<h2><strong>C++ Analogous Concept</strong></h2>
</td>
</tr>
<tr>
<td width="172">Module</td>
<td width="354">C++ Object</td>
</tr>
<tr>
<td width="172">Module Context</td>
<td width="354">C++ Object Private Data (members). Also, importantly this is analogous to WDF drivers’ “device context”.</td>
</tr>
<tr>
<td width="172">Module Config</td>
<td width="354">C++ Object Constructor Parameters</td>
</tr>
<tr>
<td width="172">Module Public Methods</td>
<td width="354">C++ Object Public Functions</td>
</tr>
<tr>
<td width="172">Module Private Methods</td>
<td width="354">C++ Object Private Functions</td>
</tr>
<tr>
<td width="172">Module Handle</td>
<td width="354">C++ “this” pointer</td>
</tr>
<tr>
<td width="172">Client driver</td>
<td width="354">The code that instantiates the C++ object.</td>
</tr>
</tbody>
</table>
<p>6. Each Module has its own locks. Each Module is responsible for locking its own private context. Thus, locking is granular but, at the same time, efficient and easy to understand.</p>
<p>7. Modules can be used by the client driver or by other Modules; are agnostic about the code that uses them.</p>
<p>8. Modules can use any number of child Modules. Child Modules, in turn, can use any number of Child Modules.</p>
<p>9. DMF provides default implementations for many driver routines such as DriverEntry, AddDevice, WDF Queue creation, so that simple driver (aka Container driver) can be created with as little code as possible.</p>
<p>10. The client driver only needs to instantiate the Module that the driver needs. Child Modules (if any) required are automatically instantiated by DMF on behalf of the driver.</p>
<p>11. Modules support inheritance. If you want to modify or add capabilities to an existing Module X, it is easy to make a Module Y that is a parent of X. Y then reuses X but provides other functionality as needed.</p>
<p>12. Modules can directly receive all WDF callbacks that are received by the client driver.</p>
<p>13. DMF supports all WDF drivers: KMDF/UMDF, Bus/Filter/Function Drivers, Miniport Drivers, C / C++ Drivers.</p>
<p>14. You can easily integrate DMF into their existing drivers or easily write new drivers from scratch.</p>
<h1>DMF Modules</h1>
<p>The current release of DMF includes these Modules:</p>
<table width="677">
<tbody>
<tr>
<td width="276">
<h2><strong>Modules for buffer management</strong></h2>
</td>
<td width="402">
<h2><strong>Description</strong></h2>
</td>
</tr>
<tr>
<td width="276"><strong>DMF_BufferPool                                   </strong></td>
<td width="402">Provides a list of zero or more pre-allocated buffers with bounds-checking validation and timer logic to manage lifetime of buffers. This is a fundamental block used by many other Modules.</td>
</tr>
<tr>
<td width="276"><strong>DMF_BufferQueue</strong></td>
<td width="402">This data structure is composed of two DMF_BufferPool instances providing producer/consumer usage pattern.</td>
</tr>
<tr>
<td width="276"><strong>DMF_PingPongBuffer</strong></td>
<td width="402">Provides a “ping-pong” buffer that allows the Client to read from one part of the buffer which contains fully transmitted/processed data while another part of the Client code continues populating a new partially filled buffer.</td>
</tr>
<tr>
<td width="276"><strong>DMF_RingBuffer</strong></td>
<td width="402">Provides a classic ring-buffer data structure.</td>
</tr>
<tr>
<td width="276"><strong>DMF_ThreadedBufferQueue</strong></td>
<td width="402">Allows the Client to enqueue work. That work is then processed synchronously. Client may optionally wait for work to complete. This is a good example of how Modules can use other Modules to create more complex Modules.</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<table width="677">
<tbody>
<tr>
<td width="276">
<h2><strong>Modules for task management</strong></h2>
</td>
<td width="402">
<h2><strong>Description</strong></h2>
</td>
</tr>
<tr>
<td width="276"><strong>DMF_QueuedWorkitem</strong></td>
<td width="402">This Module enhances the WDFWORKITEM primitive in two ways: 1. Allows Client to enqueue work items even if they are already enqueued. 2. Allows a call specific context to be enqueued.</td>
</tr>
<tr>
<td width="276"><strong>DMF_ScheduledTask</strong></td>
<td width="402">Allows the Client to specify that an operation should happen a single time, either for the lifetime of the machine or for the current boot cycle.</td>
</tr>
<tr>
<td width="276"><strong>DMF_Thread</strong></td>
<td width="402">This Module creates a thread and associated “stop” event, a ‘work ready” event and a provides callback function to the Client. An internal callback function waits for the above events and calls the Client callback when the “work-ready” event is set.</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<table width="677">
<tbody>
<tr>
<td width="276">
<h2><strong>Modules for notification</strong></h2>
</td>
<td width="402">
<h2><strong>Description</strong></h2>
</td>
</tr>
<tr>
<td width="276"><strong>DMF_NotifyUserWithEvent</strong></td>
<td width="402">Allows the client driver to easily set up an event in Kernel-mode that is also accessible in User-mode.</td>
</tr>
<tr>
<td width="276"><strong>DMF_NotifyUserWithRequest</strong></td>
<td width="402">Allows a Client to notify User-mode of events using the classic IOCTL from User-mode pattern. Data can be sent with the event.</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<table width="677">
<tbody>
<tr>
<td width="276">
<h2><strong>Modules for accessing various I/O targets</strong></h2>
</td>
<td width="402">
<h2><strong>Description</strong></h2>
</td>
</tr>
<tr>
<td width="276"><strong>DMF SelfTarget</strong></td>
<td width="402">Allows the client driver to send a WDFREQUEST to its own stack.</td>
</tr>
<tr>
<td width="276"><strong>DMF_AcpiTarget</strong></td>
<td width="402">Allows the client driver to query ACPI in various ways. It allows the Client to easily query/invoke/evaluate DSM methods.</td>
</tr>
<tr>
<td width="276"><strong>DMF_ContinuousRequestTarget</strong></td>
<td width="402">Allows the Client to send requests to WDFIOTARGET in a continuous manner. It is similar to the WDF UsbContinuousReader object but it works for all WDFIOTARGETS.</td>
</tr>
<tr>
<td width="276"><strong>DMF_DeviceInterfaceTarget</strong></td>
<td width="402">Allows the Client to register for a PnP Notification an interface and automatically manage the arrival and removal of the associated device. It also allows the Client send requests in a continuous manner using DMF_ContinuousRequestTarget as a Child Module.</td>
</tr>
<tr>
<td width="276"><strong>DMF_GpioTarget</strong></td>
<td width="402">Allows the client driver to communicate with the GPIO pins exposed by the GPIO WDFIOTARGET. This Module automatically looks for the GPIO resources and opens the appropriate targets based on settings set by the Client.</td>
</tr>
<tr>
<td width="276"><strong>DMF_HidTarget</strong></td>
<td width="402">Allows the client driver to communicate with an underlying HID WDFIOTARGET. Methods are provided that allow the Client to work with input/output/feature reports.</td>
</tr>
<tr>
<td width="276"><strong>DMF_I2cTarget</strong></td>
<td width="402">Allows the Client to communicate with an I2C bus that is exposed by SPB.  This Module automatically looks for the I2C resources and opens the appropriate targets based on settings set by the Client.</td>
</tr>
<tr>
<td width="276"><strong>DMF_RequestTarget</strong></td>
<td width="402">Contains code that builds and send requests. It can be used with any WDFIOTARGET.</td>
</tr>
<tr>
<td width="276"><strong>DMF_ResourceHub</strong></td>
<td width="402">Allows the client driver to communicate with a Resource Hub WDFIOTARGET. The Module contains all the code need to parse the type resource and other information.</td>
</tr>
<tr>
<td width="276"><strong>DMF_SerialTarget</strong></td>
<td width="402">Allows the client driver to open Serial IO Stream target and send requests.</td>
</tr>
<tr>
<td width="276"><strong>DMF_SpiTarget</strong></td>
<td width="402">Allows the client driver to communicate with an SPI bus that is exposed by SPB.</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<table width="677">
<tbody>
<tr>
<td width="276">
<h2><strong>Miscellaneous utility Modules</strong></h2>
</td>
<td width="402">
<h2><strong>Description</strong></h2>
</td>
</tr>
<tr>
<td width="276"><strong>DMF_AcpiNotification</strong></td>
<td width="402">Allows the client driver to register for and receive asynchronous notifications via ACPI.</td>
</tr>
<tr>
<td width="276"><strong>DMF_AlertableSleep</strong></td>
<td width="402">Allows the client driver to cause a thread to sleep and cancel that sleep at any time.</td>
</tr>
<tr>
<td width="276"><strong>DMF_ButtonTargetViaMsGpio</strong></td>
<td width="402">Allows the client driver to communicate with the device interfaces exposed by MSGPIOWIN32. These interfaces allow the driver to inject button and tablet related messages.</td>
</tr>
<tr>
<td width="276"><strong>DMF_CrashDump</strong></td>
<td width="402">Allows the client driver to easily write data to the Windows Crash Dump file when the system crashes.</td>
</tr>
<tr>
<td width="276"><strong>DMF_IoctlHandler</strong></td>
<td width="402">Allows the Client to more easily handle IOCTLs. Client provides a table of supported IOCTLS, the kind of access required, and the minimum/maximum sizes of the input/output buffers as well as a callback that processes the IOCTL.</td>
</tr>
<tr>
<td width="276"><strong>DMF_Pdo</strong></td>
<td width="402">Allows the client driver to easily create PDOs for enumerating virtual devices.</td>
</tr>
<tr>
<td width="276"><strong>DMF_Registry</strong></td>
<td width="402">Provides functions that allow the client driver to work easily with the Registry.</td>
</tr>
<tr>
<td width="276"><strong>DMF_SmbiosWmi</strong></td>
<td width="402">Allows the client driver to read the SMBIOS data which the Module retrieves using WMI.</td>
</tr>
<tr>
<td width="276"><strong>DMF_VirtualHidDeviceVhf</strong></td>
<td width="402">This Module is a wrapper around the VHF API. Modules use this Module as a Child Module to create virtual HID devices. Those parent Modules expose Methods that are specific to that virtual HID device.</td>
</tr>
<tr>
<td width="276"><strong>DMF_VirtualHidKeyboard</strong></td>
<td width="402">Provides an example of how to create a Virtual HID device using DMF_VirtualHidDeviceVhf.</td>
</tr>
<tr>
<td width="276"><strong>DMF_Wmi</strong></td>
<td width="402">Allows the client driver work with the WMI API easily.</td>
</tr>
</tbody>
</table>
<h1>DMF resources</h1>
<p>DMF and its Modules, templates and sample code have been shared for public use on <a href="https://github.com/Microsoft/DMF">Github</a>. We will continue to improve the code and add new Modules in the open-source repository. Also, look forward to more sample drivers that show different features of DMF and to help you understand the various ways DMF can be used.</p>
<p>DMF has been designed with the goal to develop and maintain quality drivers with maximum efficiency and maintainability. It’s now being shared to the world as open source so the Windows ecosystem can leverage this framework and utility-modules to write quality drivers. WDF over a decade ago brought tremendous improvement over WDM and changed the driver landscape, however it has not provided an ability for a 3<sup>rd</sup> party driver house to create extensions/libraries that plug seamlessly into the WDF messaging model and can be shared across drivers.</p>
<p>We are confident that DMF will help you develop and maintain quality drivers with maximum efficiency and maintainability.</p>
<p>Look out for more posts about DMF. We intend to answer your questions, so please post your comments on <a href="https://github.com/Microsoft/DMF">Github</a>!</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/15/introducing-driver-module-framework/">Introducing Driver Module Framework</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></content:encoded>
			<wfw:commentRss>https://blogs.windows.com/buildingapps/2018/08/15/introducing-driver-module-framework/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Announcing Windows Community Toolkit v4.0</title>
		<link>https://blogs.windows.com/buildingapps/2018/08/08/announcing-windows-community-toolkit-v4-0/</link>
		<comments>https://blogs.windows.com/buildingapps/2018/08/08/announcing-windows-community-toolkit-v4-0/#respond</comments>
		<pubDate>Wed, 08 Aug 2018 15:00:09 +0000</pubDate>
		<dc:creator><![CDATA[Nikola Metulev]]></dc:creator>
				<category><![CDATA[PC]]></category>
		<category><![CDATA[.NET]]></category>
		<category><![CDATA[Microsoft Graph]]></category>
		<category><![CDATA[Windows Community Toolkit]]></category>
		<category><![CDATA[XAML]]></category>

		<guid isPermaLink="false">http://blogs.windows.com/buildingapps/?p=53925</guid>
		<description><![CDATA[<p>The Windows Community Toolkit recently reached over 1 million downloads across all nuget packages. This is a very big milestone for the community and I’m very excited to announce yet another major update to the Windows Community Toolkit, version 4.0. With the help of the Windows community, this update introduces several new additions and improvements, [&#8230;]</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/08/announcing-windows-community-toolkit-v4-0/">Announcing Windows Community Toolkit v4.0</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p>The Windows Community Toolkit recently reached over 1 million downloads across all nuget packages. This is a very big milestone for the community and I’m very excited to announce yet another major update to the Windows Community Toolkit, version 4.0. With the help of the Windows community, this update introduces several new additions and improvements, specifically:</p>
<ul>
<li>New DataGrid with fluent design for all UWP developers</li>
<li>Two new Microsoft Graph controls. PowerBIEmbedded enables embedding PowerBI dashboards in your UWP apps and PlannerTasksList allows users to work with Microsoft Planner tasks</li>
<li>The Twitter, LinkedIn, and Microsoft Translator services have moved to the .NET Standard services package and available to even more developers, including desktop and Xamarin developers</li>
<li>Strong-named packages for those developers that require strong-named assemblies</li>
<li>Dark theme support for the sample app and theme chooser for each sample</li>
</ul>
<p>These are some of the biggest updates in this release and I encourage you to view the <a href="https://github.com/Microsoft/WindowsCommunityToolkit/releases">full release notes</a> on our GitHub. Let’s take a look at some of these updates in more details.</p>
<p><img class="aligncenter size-large wp-image-53931" src="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/a50f5b37a049312300548b30923da89d-1024x626.png" alt="The latest updates to Windows Community Toolkit." width="1024" height="626" srcset="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/a50f5b37a049312300548b30923da89d-1024x626.png 1024w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/a50f5b37a049312300548b30923da89d-300x183.png 300w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/a50f5b37a049312300548b30923da89d-768x469.png 768w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<h2>New fluent DataGrid control</h2>
<p>We had introduced a preview of a fluent <strong><a href="https://aka.ms/win10datagriddoc">DataGrid control</a></strong> for Windows 10 in Version 3.0. In the past several months, we have added a few more features based on community feedback, ensured more reliability and better accessibility for the DataGrid control. We are now pleased to announce the general availability of the DataGrid control.</p>
<p>The DataGrid control is a robust control that provides a flexible way to display a collection of data in rows and columns. It retains the programming model for DataGrid from Silverlight and WPF so it is familiar to XAML developers who have used the DataGrid control in older XAML technologies. Developers can now create highly flexible tabular visualization of data with editing, data validation and data shaping functionalities with a few simple lines of code in Windows 10:</p>
<pre class="brush: xml; title: ; notranslate">

&lt;controls:DataGrid x:Name=&quot;dataGrid1&quot; 
    Height=&quot;600&quot; Margin=&quot;12&quot;
    AutoGenerateColumns=&quot;True&quot;
    ItemsSource=&quot;{x:Bind MyViewModel.Customers}&quot; /&gt; 

</pre>
<p><img class="aligncenter size-large wp-image-53934" src="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/bab5f5f06fd65fc284a728396eaae3aa-1024x844.png" alt="Create highly flexible tabular visualization of data with editing, data validation and data shaping functionalities with a few simple lines of code." width="1024" height="844" srcset="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/bab5f5f06fd65fc284a728396eaae3aa-1024x844.png 1024w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/bab5f5f06fd65fc284a728396eaae3aa-300x247.png 300w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/bab5f5f06fd65fc284a728396eaae3aa-768x633.png 768w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/bab5f5f06fd65fc284a728396eaae3aa.png 1447w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p>Make sure to visit the <a href="https://aka.ms/win10datagriddoc">DataGrid documentation</a> to learn about the capabilities of the DataGrid control with detailed guidance documents and How-Tos with code samples. DataGrid comes in a standalone nuget package that you can download and add reference to.</p>
<h2>New Microsoft Graph controls</h2>
<p>Version 3 of the toolkit introduced a new category of UWP controls to enable developers access the Microsoft Graph. With few lines of code, developers can add UI to enable users to log in to the Microsoft Graph, search for coworkers and friends, browse SharePoint files and more. Version 4.0 introduces two new Microsoft Graph controls: <strong><a href="https://docs.microsoft.com/windows/communitytoolkit/graph/plannertasklist">PlannerTaskList</a></strong> and <strong><a href="https://docs.microsoft.com/windows/communitytoolkit/graph/powerbiembedded">PowerBIEmbedded</a></strong>.</p>
<p>The <strong>PlannerTaskList</strong> enables developers to integrate tasks directly in their apps and allow users to interact with the Microsoft Planner tasks. Teams and individuals depend on Microsoft Planner to get organized quickly, work together effortlessly, and stay on the same page.</p>
<p><img class="aligncenter size-large wp-image-53937" src="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/bd25ebabfa7a97657a7330784602f813-1024x738.png" alt="The PlannerTaskList enables developers to integrate tasks directly in their apps and allow users to interact with the Microsoft Planner tasks." width="1024" height="738" srcset="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/bd25ebabfa7a97657a7330784602f813-1024x738.png 1024w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/bd25ebabfa7a97657a7330784602f813-300x216.png 300w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/bd25ebabfa7a97657a7330784602f813-768x554.png 768w" sizes="(max-width: 1024px) 100vw, 1024px" /></p>
<p>The <strong>PowerBIEmbedded</strong> control enables developers to embed a rich PowerBI dashboard directly in their apps and allow users to interact with the rich data directly.</p>
<h2>Moved Twitter, LinkedIn, and Microsoft Translator services to .NET Standard</h2>
<p>The Windows Community Toolkit contains APIs to make it easy to work with web services such as Twitter, OneDrive, LinkedIn, Microsoft Graph and more. Originally only available to only UWP developers, with this update, most services have moved to our .NET Standard services package (<strong>Microsoft.Toolkit.Services</strong>). These services are now available to any framework implementing .NET Standard 1.4 and above, which includes UWP, the .NET Framework (including WPF and WinForms), Xamarin, .NET Core and many more.</p>
<h2>Get started today</h2>
<p>As a reminder, you can <a href="https://docs.microsoft.com/windows/communitytoolkit/getting-started">get started by following this tutorial</a>, or preview the latest features by installing the <a href="https://www.microsoft.com/store/apps/9nblggh4tlcq">Windows Community Toolkit Sample App</a> from the Microsoft Store. If you would like to contribute, <a href="https://github.com/Microsoft/WindowsCommunityToolkit/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22">please join us on GitHub</a>! To join the conversation on Twitter, use the <strong>#windowstoolkit</strong> hashtag.</p>
<p>Happy coding!</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/08/announcing-windows-community-toolkit-v4-0/">Announcing Windows Community Toolkit v4.0</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></content:encoded>
			<wfw:commentRss>https://blogs.windows.com/buildingapps/2018/08/08/announcing-windows-community-toolkit-v4-0/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>What’s your monetization strategy?</title>
		<link>https://blogs.windows.com/buildingapps/2018/08/07/whats-your-monetization-strategy/</link>
		<comments>https://blogs.windows.com/buildingapps/2018/08/07/whats-your-monetization-strategy/#respond</comments>
		<pubDate>Tue, 07 Aug 2018 17:00:27 +0000</pubDate>
		<dc:creator><![CDATA[Microsoft Store Team]]></dc:creator>
				<category><![CDATA[PC]]></category>
		<category><![CDATA[ad monetization]]></category>
		<category><![CDATA[ads]]></category>
		<category><![CDATA[microsoft store]]></category>

		<guid isPermaLink="false">http://blogs.windows.com/buildingapps/?p=53904</guid>
		<description><![CDATA[<p>Selecting how to monetize your app is a big part of any development process. Different kinds of apps can have very different opportunities and needs—so your monetization strategy can inform not just your business model, but your app’s final design, content, and code. Microsoft Store offers a variety of different ways to add monetization to [&#8230;]</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/07/whats-your-monetization-strategy/">What’s your monetization strategy?</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p>Selecting how to monetize your app is a big part of any development process. Different kinds of apps can have very different opportunities and needs—so your monetization strategy can inform not just your business model, but your app’s final design, content, and code.</p>
<p>Microsoft Store offers a variety of different ways to add monetization to your app. <strong>Here’s a quick breakdown of our 4 biggest earners and how they can work for you.</strong></p>
<h1><b>Base price</b></h1>
<p>Charging an up-front <a href="https://docs.microsoft.com/en-us/windows/uwp/publish/set-and-schedule-app-pricing">base price</a> is a one-time transaction: you offer a product and the user pays for it. Microsoft Store allows you to change your base price at any time, in any market, so you can always experiment with your numbers and see how your target audience responds.</p>
<p>A general rule of thumb for setting a base price is to scope out the competition. Once you know what the market has paid in the past, you can set a price point for your own unique product.</p>
<p>You can see from the data below that charging a base price is the most used option in the Microsoft Store for apps.</p>
<p><img class="aligncenter size-full wp-image-53913" src="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/e301c858d4b7ec6c469581040bfea413.png" alt="Graph showing that charging a base price is the most used option in the Microsoft Store for apps." width="779" height="389" srcset="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/e301c858d4b7ec6c469581040bfea413.png 779w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/e301c858d4b7ec6c469581040bfea413-300x150.png 300w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/e301c858d4b7ec6c469581040bfea413-768x384.png 768w" sizes="(max-width: 779px) 100vw, 779px" /></p>
<h1><b>In-app purchases</b></h1>
<p><a href="https://docs.microsoft.com/en-us/windows/uwp/monetize/in-app-purchases-and-trials">In-app purchases</a> are microtransactions that allow customers to purchase additional content within an app itself. These small fees can build up to big returns—a <a href="https://www.gartner.com/newsroom/id/3331117">Gartner Research report</a> revealed that customers will spend 24% more on in-app purchases than they would to buy an app outright. Once a customer sees value, they have an incentive to pay.</p>
<p>Content is king for in-app purchases. The more your customers use or enjoy your app, the more likely they are to purchase new content that is bigger, better, or simply more.</p>
<p>In-app purchase is the most chosen method to monetize for games within the Microsoft Store, as shown below.</p>
<p><img class="aligncenter size-full wp-image-53916" src="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/33d9c24ec3db9ee4f8132a8587f59b38.png" alt="Graph showing that in-app purchases are the most chosen method to monetize for games within the Microsoft Store." width="779" height="389" srcset="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/33d9c24ec3db9ee4f8132a8587f59b38.png 779w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/33d9c24ec3db9ee4f8132a8587f59b38-300x150.png 300w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/08/33d9c24ec3db9ee4f8132a8587f59b38-768x384.png 768w" sizes="(max-width: 779px) 100vw, 779px" /></p>
<h1><b>S</b><b>ubscriptions</b></h1>
<p>With <a href="https://docs.microsoft.com/en-us/windows/uwp/monetize/enable-subscription-add-ons-for-your-app">subscriptions</a>, customers pay a recurring, scheduled fee to access your app. You select the amount, the schedule, and if it covers your entire app or applies to digital products within your app, like features or content.</p>
<p>The subscription model is ideal for apps that offer continuous content and services. In addition to a reliable revenue stream, you also gain access to a quantifiable base of loyal users.</p>
<h1><b>Display mobile ads</b></h1>
<p><a href="https://developer.microsoft.com/en-us/store/monetize/ads-in-apps">Mobile advertising</a> is one of most profitable app revenue models for developers with <a href="https://docs.microsoft.com/en-us/windows/uwp/monetize/native-ads">native</a>, <a href="https://docs.microsoft.com/en-us/windows/uwp/monetize/adcontrol-in-xaml-and--net">banner</a>, and <a href="https://docs.microsoft.com/en-us/windows/uwp/monetize/interstitial-ads">interstitial</a> formats heading the list.</p>
<p>If you elect the ad route, include your designers so they can fold your advertising formats seamlessly into your app experience. You can find test ads and more information on best practices <a href="https://docs.microsoft.com/en-us/windows/uwp/monetize/best-practices-for-ads-in-apps">here</a>.</p>
<h1><b>And finally…</b></h1>
<p>No matter which monetization strategy you choose, be sure to check out <a href="https://docs.microsoft.com/en-us/windows/uwp/publish/getting-paid-apps">how you get paid</a>. Comment below on which monetization strategy you’re using!</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/08/07/whats-your-monetization-strategy/">What’s your monetization strategy?</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></content:encoded>
			<wfw:commentRss>https://blogs.windows.com/buildingapps/2018/08/07/whats-your-monetization-strategy/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Windows 10 SDK Preview Build 17723 available now!</title>
		<link>https://blogs.windows.com/buildingapps/2018/07/31/windows-10-sdk-preview-build-17723-available-now/</link>
		<comments>https://blogs.windows.com/buildingapps/2018/07/31/windows-10-sdk-preview-build-17723-available-now/#comments</comments>
		<pubDate>Tue, 31 Jul 2018 17:36:17 +0000</pubDate>
		<dc:creator><![CDATA[Clint Rutkas]]></dc:creator>
				<category><![CDATA[PC]]></category>
		<category><![CDATA[MSIX]]></category>
		<category><![CDATA[SDK]]></category>
		<category><![CDATA[Visual Studio]]></category>
		<category><![CDATA[Windows 10 SDK Preview Build]]></category>

		<guid isPermaLink="false">http://blogs.windows.com/buildingapps/?p=53883</guid>
		<description><![CDATA[<p>Today, we released a new Windows 10 Preview Build of the SDK to be used in conjunction with Windows 10 Insider Preview (Build 17723 or greater). The Preview SDK Build 17723 contains bug fixes and under development changes to the API surface area. The Preview SDK can be downloaded from developer section on Windows Insider. For feedback and [&#8230;]</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/07/31/windows-10-sdk-preview-build-17723-available-now/">Windows 10 SDK Preview Build 17723 available now!</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p>Today, we released a new Windows 10 Preview Build of the SDK to be used in conjunction with <a href="https://insider.windows.com/">Windows 10 Insider Preview</a> (Build <strong>17723 </strong>or greater). The Preview SDK Build <strong>17723 </strong>contains bug fixes and under development changes to the API surface area.</p>
<p>The Preview SDK can be downloaded from <a href="https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewSDK">developer section on Windows Insider</a>.</p>
<p>For feedback and updates to the known issues, please see the <a href="https://social.msdn.microsoft.com/Forums/en-US/home?forum=Win10SDKToolsIssues">developer forum.</a> For new developer feature requests, head over to our <a href="https://wpdev.uservoice.com/">Windows Platform UserVoice.</a></p>
<h2>Things to note:</h2>
<ul>
<li>This build works in conjunction with previously released SDKs and Visual Studio 2017. You can install this SDK and still also continue to submit your apps that target Windows 10 build 1803 or earlier to the store.</li>
<li>The Windows SDK will now formally only be supported by Visual Studio 2017 and greater. You can download the Visual Studio 2017 <a href="https://www.visualstudio.com/downloads/">here</a>.</li>
<li>This build of the Windows SDK <strong>will</strong> only install on <a href="https://insider.windows.com/">Windows 10 Insider Preview</a> builds.</li>
<li>In order to assist with script access to the SDK, the ISO will also be able to be accessed through the following URL: <a href="https://go.microsoft.com/fwlink/?prd=11966&amp;pver=1.0&amp;plcid=0x409&amp;clcid=0x409&amp;ar=Flight&amp;sar=Sdsurl&amp;o1=17723">https://go.microsoft.com/fwlink/?prd=11966&amp;pver=1.0&amp;plcid=0x409&amp;clcid=0x409&amp;ar=Flight&amp;sar=Sdsurl&amp;o1=17723</a> once the static URL is published.</li>
</ul>
<h2>C++/WinRT Update for build 17709 and beyond:</h2>
<p>This update introduces many improvements and fixes for C++/WinRT. Notably, it introduces the ability to build C++/WinRT without any dependency on the Windows SDK. This isn’t particularly interesting to the OS developer, but even in the OS repo it provides benefits because it does not itself include any Windows headers. Thus, a developer will typically pull in fewer or no dependencies inadvertently. This also means a dramatic reduction in the number of macros that a C++/WinRT developer must guard against. Removing the dependency on the Windows headers means that C++/WinRT is more portable and standards compliant and furthers our efforts to make it a cross-compiler and cross-platform library. It also means that the C++/WinRT headers will never be mangled by macros. If you previously relied on C++/WinRT to include various Windows headers that you will now have to include them yourself. It has always been good practice to always include any headers you depend on explicitly and not rely on another library to include them for you.</p>
<h3><strong>Highlights</strong></h3>
<p><strong>Support get_strong and get_weak to create delegates:</strong> This update allows a developer to use either get_strong or get_weak instead of a raw this pointer when creating a delegate pointing to a member function.</p>
<p><strong>Add async cancellation callback:</strong> The most frequently requested feature for C++/WinRT&#8217;s coroutine support has been the addition of a cancellation callback.</p>
<p><strong>Simplify the use of APIs expecting IBuffer parameters:</strong> Although most APIs prefer collections or arrays, enough APIs rely on IBuffer that it should be easier to use such APIs from C++. This update provides direct access to the data behind an IBuffer implementation using the same data naming convention used by the C++ standard library containers. This also avoids colliding with metadata names that conventionally begin with an uppercase letter.</p>
<p><strong>Conformance:</strong> Improved support for Clang and Visual C++’s stricter conformance modes.</p>
<p><strong>Improved code gen:</strong> Various improvements to reduce code size, improve inlining, and optimize factory caching.</p>
<p><strong>Remove unnecessary recursion:</strong> When the command line refers to a folder rather than a specific winmd, cppwinrt will no longer search recursively for winmd files. It causes performance problems in the OS build and can lead to usage errors that are hard to diagnose when developers inadvertently cause cppwinrt to consume more winmds than expected. The cppwinrt compiler also now handles duplicates more intelligently, making it more resilient to user error and poorly-formed winmd files.</p>
<p><strong>Declare both WINRT_CanUnloadNow and WINRT_GetActivationFactory in base.h:</strong> Callers don’t need to declare them directly. Their signatures have also changed, amounting to a breaking change. The declarations alleviate most of the pain of this change. The change is necessitated by the fact that C++/WinRT no longer depends on the Windows headers and this change removes the dependency on the types from the Windows headers.</p>
<p><strong>Harden smart pointers:</strong> The event revokers didn’t revoke when move-assigned a new value. This lead me to take a closer look at the smart pointer classes and I noticed that they were not reliably handling self-assignment. This is rooted in the com_ptr class template that most of the others rely on. I fixed com_ptr and updated the event revokers to handle move semantics correctly to ensure that they revoke upon assignment. The handle class template has also been hardened by the removal of the implicit constructor that made it easy to write incorrect code. This also turned bugs in the OS into compiler errors fixed in this PR.</p>
<h3><strong>Breaking Changes</strong></h3>
<p>Support for non-WinRT interfaces is disabled by default. To enable, simply #include &lt;unknwn.h&gt; before any C++/WinRT headers.</p>
<p>winrt::get_abi(winrt::hstring) now returns void* instead of HSTRING. Code requiring the HSTRING ABI can simply use a static_cast.</p>
<p>winrt::put_abi(winrt::hstring) returns void** instead of HSTRING*. Code requiring the HSTRING ABI can simply use a reinterpret_cast.</p>
<p>HRESULT is now projected as winrt::hresult. Code requiring an HRESULT can simply static_cast if you need to do type checking or support type traits, but it is otherwise convertible as long as &lt;unknwn.h&gt; is included first.</p>
<p>GUID is now projected as winrt::guid. Code implementing APIs with GUID parameters must use winrt::guid instead, but it is otherwise convertible as long as &lt;unknwn.h&gt; is included first.</p>
<p>The signatures of WINRT_CanUnloadNow and WINRT_GetActivationFactory has changed. Code must not declare these functions at all and instead include winrt/base.h to include their declarations.</p>
<p>The winrt::handle constructor is now explicit. Code assigning a raw handle value must call the attach method instead.</p>
<p>winrt::clock::from_FILETIME has been deprecated. Code should use winrt::clock::from_file_time instead.</p>
<h2>What&#8217;s New:</h2>
<h3><strong>MSIX Support</strong></h3>
<p>It’s finally here! You can now package your applications as MSIX! These applications can be installed and run on any device with <strong>17682</strong> build or later.</p>
<p>To package your application with MSIX, use the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh446767(v=vs.85).aspx">MakeAppx tool</a>. To install the application – just click on the MSIX file. To understand more about MSIX, watch this introductory video: <a href="https://channel9.msdn.com/events/Build/2018/BRK2432?term=msix%20inside%20and%20out">link</a></p>
<p>Feedback and comments are welcome on our MSIX community: <a href="http://aka.ms/MSIXCommunity">http://aka.ms/MSIXCommunity</a></p>
<p>MSIX is not currently supported by the App Certification Kit nor the Microsoft Store at this time.</p>
<h3><strong>MC.EXE</strong></h3>
<p>We’ve made some important changes to the C/C++ ETW code generation of mc.exe (Message Compiler):</p>
<p>The “-mof” parameter is deprecated. This parameter instructs MC.exe to generate ETW code that is compatible with Windows XP and earlier. Support for the “-mof” parameter will be removed in a future version of mc.exe.</p>
<p>As long as the “-mof” parameter is not used, the generated C/C++ header is now compatible with both kernel-mode and user-mode, regardless of whether “-km” or “-um” was specified on the command line. The header will use the _ETW_KM_ macro to automatically determine whether it is being compiled for kernel-mode or user-mode and will call the appropriate ETW APIs for each mode.</p>
<ul>
<li>The only remaining difference between “-km” and “-um” is that the EventWrite[EventName] macros generated with “-km” have an Activity ID parameter while the EventWrite[EventName] macros generated with “-um” do not have an Activity ID parameter.</li>
</ul>
<p>The EventWrite[EventName] macros now default to calling EventWriteTransfer (user mode) or EtwWriteTransfer (kernel mode). Previously, the EventWrite[EventName] macros defaulted to calling EventWrite (user mode) or EtwWrite (kernel mode).</p>
<ul>
<li>The generated header now supports several customization macros. For example, you can set the MCGEN_EVENTWRITETRANSFER macro if you need the generated macros to call something other than EventWriteTransfer.</li>
<li>The manifest supports new attributes.
<ul>
<li>Event “name”: non-localized event name.</li>
<li>Event “attributes”: additional key-value metadata for an event such as filename, line number, component name, function name.</li>
<li>Event “tags”: 28-bit value with user-defined semantics (per-event).</li>
<li>Field “tags”: 28-bit value with user-defined semantics (per-field – can be applied to “data” or “struct” elements).</li>
</ul>
</li>
</ul>
<ul>
<li>You can now define “provider traits” in the manifest (e.g. provider group). If provider traits are used in the manifest, the EventRegister[ProviderName] macro will automatically register them.</li>
<li>MC will now report an error if a localized message file is missing a string. (Previously MC would silently generate a corrupt message resource.)</li>
<li>MC can now generate Unicode (utf-8 or utf-16) output with the “-cp utf-8” or “-cp utf-16” parameters.</li>
</ul>
<h2>Known Issues:</h2>
<p>The SDK headers are generated with types in the “ABI” namespace. This is done to avoid conflicts with C++/CX and C++/WinRT clients that need to consume types directly at the ABI layer[1]. By default, types emitted by MIDL are *<strong>not</strong>* put in the ABI namespace, however this has the potential to introduce conflicts from teams attempting to consume ABI types from Windows WinRT MIDL generated headers and non-Windows WinRT MIDL generated headers (this is especially challenging if the non-Windows header references Windows types).</p>
<p>To ensure that developers have a consistent view of the WinRT API surface, validation has been added to the generated headers to ensure that the ABI prefix is consistent between the Windows headers and user generated headers. If you encounter an error like:</p>
<p>5&gt;c:\program files (x86)\windows kits\10\include\10.0.17687.0\winrt\windows.foundation.h(83): error C2220: warning treated as error &#8211; no &#8216;object&#8217; file generated</p>
<p>5&gt;c:\program files (x86)\windows kits\10\include\10.0.17687.0\winrt\windows.foundation.h(83): warning C4005: &#8216;CHECK_NS_PREFIX_STATE&#8217;: macro redefinition</p>
<p>5&gt;g:\&lt;PATH TO YOUR HEADER HERE&gt;(41): note: see previous definition of &#8216;CHECK_NS_PREFIX_STATE&#8217;</p>
<p>It means that some of your MIDL generated headers are inconsistent with the system generated headers.</p>
<p>There are two ways to fix this:</p>
<ul>
<li><strong>Preferred:</strong> Compile your IDL file with the /ns_prefix MIDL command line switch. This will cause all your types to be moved to the ABI namespace consistent with the Windows headers. This may require code changes in your code however.</li>
<li><strong>Alternate:</strong> Add #define DISABLE_NS_PREFIX_CHECKS before including the Windows headers. This will suppress the validation.</li>
</ul>
<h2>API Updates, Additions and Removals</h2>
<p>When targeting new APIs, consider writing your app to be adaptive in order to run correctly on the widest number of Windows 10 devices. Please see <a href="https://blogs.windows.com/buildingapps/2015/09/15/dynamically-detecting-features-with-api-contracts-10-by-10/#HdHAk5RVtCg6bW4O.97">Dynamically detecting features with API contracts (10 by 10)</a> for more information.</p>
<p>The following APIs have been added to the platform since the release of 17134.  The APIs listed below have been removed.</p>
<h2>Additions:</h2>
<pre class="brush: csharp; title: ; notranslate">

namespace Windows.AI.MachineLearning {
  public interface ILearningModelFeatureDescriptor
  public interface ILearningModelFeatureValue
  public interface ILearningModelOperatorProvider
  public sealed class ImageFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class ImageFeatureValue : ILearningModelFeatureValue
  public interface ITensor : ILearningModelFeatureValue
  public sealed class LearningModel : IClosable
  public sealed class LearningModelBinding : IIterable&lt;IKeyValuePair&lt;string, object&gt;&gt;, IMapView&lt;string, object&gt;
  public sealed class LearningModelDevice
  public enum LearningModelDeviceKind
  public sealed class LearningModelEvaluationResult
  public enum LearningModelFeatureKind
  public sealed class LearningModelSession : IClosable
  public struct MachineLearningContract
  public sealed class MapFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class SequenceFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class TensorBoolean : ILearningModelFeatureValue, ITensor
  public sealed class TensorDouble : ILearningModelFeatureValue, ITensor
  public sealed class TensorFeatureDescriptor : ILearningModelFeatureDescriptor
  public sealed class TensorFloat : ILearningModelFeatureValue, ITensor
  public sealed class TensorFloat16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt32Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt64Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorInt8Bit : ILearningModelFeatureValue, ITensor
  public enum TensorKind
  public sealed class TensorString : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt16Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt32Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt64Bit : ILearningModelFeatureValue, ITensor
  public sealed class TensorUInt8Bit : ILearningModelFeatureValue, ITensor
}
namespace Windows.ApplicationModel {
  public sealed class AppInstallerInfo
  public sealed class LimitedAccessFeatureRequestResult
  public static class LimitedAccessFeatures
  public enum LimitedAccessFeatureStatus
  public sealed class Package {
    IAsyncOperation&lt;PackageUpdateAvailabilityResult&gt; CheckUpdateAvailabilityAsync();
    AppInstallerInfo GetAppInstallerInfo();
  }
  public enum PackageUpdateAvailability
  public sealed class PackageUpdateAvailabilityResult
}
namespace Windows.ApplicationModel.Calls {
  public sealed class VoipCallCoordinator {
    IAsyncOperation&lt;VoipPhoneCallResourceReservationStatus&gt; ReserveCallResourcesAsync();
  }
}
namespace Windows.ApplicationModel.Chat {
  public static class ChatCapabilitiesManager {
    public static IAsyncOperation&lt;ChatCapabilities&gt; GetCachedCapabilitiesAsync(string address, string transportId);
    public static IAsyncOperation&lt;ChatCapabilities&gt; GetCapabilitiesFromNetworkAsync(string address, string transportId);
  }
  public static class RcsManager {
    public static event EventHandler&lt;object&gt; TransportListChanged;
  }
}
namespace Windows.ApplicationModel.DataTransfer {
  public static class Clipboard {
    public static event EventHandler&lt;ClipboardHistoryChangedEventArgs&gt; HistoryChanged;
    public static event EventHandler&lt;object&gt; HistoryEnabledChanged;
    public static event EventHandler&lt;object&gt; RoamingEnabledChanged;
    public static bool ClearHistory();
    public static bool DeleteItemFromHistory(ClipboardHistoryItem item);
    public static IAsyncOperation&lt;ClipboardHistoryItemsResult&gt; GetHistoryItemsAsync();
    public static bool IsHistoryEnabled();
    public static bool IsRoamingEnabled();
    public static bool SetContentWithOptions(DataPackage content, ClipboardContentOptions options);
    public static SetHistoryItemAsContentStatus SetHistoryItemAsContent(ClipboardHistoryItem item);
  }
  public sealed class ClipboardContentOptions
  public sealed class ClipboardHistoryChangedEventArgs
  public sealed class ClipboardHistoryItem
  public sealed class ClipboardHistoryItemsResult
  public enum ClipboardHistoryItemsResultStatus
  public sealed class DataPackagePropertySetView : IIterable&lt;IKeyValuePair&lt;string, object&gt;&gt;, IMapView&lt;string, object&gt; {
    bool IsFromRoamingClipboard { get; }
    string SourceDisplayName { get; }
  }
  public enum SetHistoryItemAsContentStatus
}
namespace Windows.ApplicationModel.Store.Preview {
  public enum DeliveryOptimizationDownloadMode
  public enum DeliveryOptimizationDownloadModeSource
  public sealed class DeliveryOptimizationSettings
  public static class StoreConfiguration {
    public static bool IsPinToDesktopSupported();
    public static bool IsPinToStartSupported();
    public static bool IsPinToTaskbarSupported();
    public static void PinToDesktop(string appPackageFamilyName);
    public static void PinToDesktopForUser(User user, string appPackageFamilyName);
  }
}
namespace Windows.ApplicationModel.Store.Preview.InstallControl {
  public enum AppInstallationToastNotificationMode
  public sealed class AppInstallItem {
    AppInstallationToastNotificationMode CompletedInstallToastNotificationMode { get; set; }
    AppInstallationToastNotificationMode InstallInProgressToastNotificationMode { get; set; }
    bool PinToDesktopAfterInstall { get; set; }
    bool PinToStartAfterInstall { get; set; }
    bool PinToTaskbarAfterInstall { get; set; }
  }
  public sealed class AppInstallManager {
    bool CanInstallForAllUsers { get; }
  }
  public sealed class AppInstallOptions {
    string CampaignId { get; set; }
    AppInstallationToastNotificationMode CompletedInstallToastNotificationMode { get; set; }
    string ExtendedCampaignId { get; set; }
    bool InstallForAllUsers { get; set; }
   AppInstallationToastNotificationMode InstallInProgressToastNotificationMode { get; set; }
    bool PinToDesktopAfterInstall { get; set; }
    bool PinToStartAfterInstall { get; set; }
    bool PinToTaskbarAfterInstall { get; set; }
    bool StageButDoNotInstall { get; set; }
  }
  public sealed class AppUpdateOptions {
    bool AutomaticallyDownloadAndInstallUpdateIfFound { get; set; }
  }
}
namespace Windows.ApplicationModel.UserActivities {
  public sealed class UserActivity {
    bool IsRoamable { get; set; }
  }
}
namespace Windows.Data.Text {
  public sealed class TextPredictionGenerator {
    CoreTextInputScope InputScope { get; set; }
    IAsyncOperation&lt;IVectorView&lt;string&gt;&gt; GetCandidatesAsync(string input, uint maxCandidates, TextPredictionOptions predictionOptions, IIterable&lt;string&gt; previousStrings);
    IAsyncOperation&lt;IVectorView&lt;string&gt;&gt; GetNextWordCandidatesAsync(uint maxCandidates, IIterable&lt;string&gt; previousStrings);
  }
  public enum TextPredictionOptions : uint
}
namespace Windows.Devices.Display.Core {
  public sealed class DisplayAdapter
  public enum DisplayBitsPerChannel : uint
  public sealed class DisplayDevice
  public enum DisplayDeviceCapability
  public sealed class DisplayFence
  public sealed class DisplayManager : IClosable
  public sealed class DisplayManagerChangedEventArgs
  public sealed class DisplayManagerDisabledEventArgs
  public sealed class DisplayManagerEnabledEventArgs
  public enum DisplayManagerOptions : uint
  public sealed class DisplayManagerPathsFailedOrInvalidatedEventArgs
  public enum DisplayManagerResult
  public sealed class DisplayManagerResultWithState
  public sealed class DisplayModeInfo
  public enum DisplayModeQueryOptions : uint
  public sealed class DisplayPath
  public enum DisplayPathScaling
  public enum DisplayPathStatus
  public struct DisplayPresentationRate
  public sealed class DisplayPrimaryDescription
  public enum DisplayRotation
  public sealed class DisplayScanout
  public sealed class DisplaySource
  public sealed class DisplayState
  public enum DisplayStateApplyOptions : uint
  public enum DisplayStateFunctionalizeOptions : uint
  public sealed class DisplayStateOperationResult
  public enum DisplayStateOperationStatus
  public sealed class DisplaySurface
  public sealed class DisplayTarget
  public enum DisplayTargetPersistence
  public sealed class DisplayTask
  public sealed class DisplayTaskPool
  public enum DisplayTaskSignalKind
  public sealed class DisplayView
  public sealed class DisplayWireFormat
  public enum DisplayWireFormatColorSpace
  public enum DisplayWireFormatEotf
  public enum DisplayWireFormatHdrMetadata
  public enum DisplayWireFormatPixelEncoding
}
namespace Windows.Devices.Enumeration {
  public enum DeviceInformationKind {
    DevicePanel = 8,
  }
  public sealed class DeviceInformationPairing {
    public static bool TryRegisterForAllInboundPairingRequestsWithProtectionLevel(DevicePairingKinds pairingKindsSupported, DevicePairingProtectionLevel minProtectionLevel);
  }
}
namespace Windows.Devices.Enumeration.Pnp {
  public enum PnpObjectType {
    DevicePanel = 8,
  }
}
namespace Windows.Devices.Lights {
  public sealed class LampArray
  public enum LampArrayKind
  public sealed class LampInfo
  public enum LampPurposes : uint
}
namespace Windows.Devices.Lights.Effects {
  public interface ILampArrayEffect
  public sealed class LampArrayBitmapEffect : ILampArrayEffect
  public sealed class LampArrayBitmapRequestedEventArgs
  public sealed class LampArrayBlinkEffect : ILampArrayEffect
  public sealed class LampArrayColorRampEffect : ILampArrayEffect
  public sealed class LampArrayCustomEffect : ILampArrayEffect
  public enum LampArrayEffectCompletionBehavior
  public sealed class LampArrayEffectPlaylist : IIterable&lt;ILampArrayEffect&gt;, IVectorView&lt;ILampArrayEffect&gt;
  public enum LampArrayEffectStartMode
  public enum LampArrayRepetitionMode
  public sealed class LampArraySolidEffect : ILampArrayEffect
  public sealed class LampArrayUpdateRequestedEventArgs
}
namespace Windows.Devices.PointOfService {
  public sealed class BarcodeScannerCapabilities {
    bool IsVideoPreviewSupported { get; }
  }
  public sealed class ClaimedBarcodeScanner : IClosable {
    event TypedEventHandler&lt;ClaimedBarcodeScanner, ClaimedBarcodeScannerClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedBarcodeScannerClosedEventArgs
  public sealed class ClaimedCashDrawer : IClosable {
    event TypedEventHandler&lt;ClaimedCashDrawer, ClaimedCashDrawerClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedCashDrawerClosedEventArgs
  public sealed class ClaimedLineDisplay : IClosable {
    event TypedEventHandler&lt;ClaimedLineDisplay, ClaimedLineDisplayClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedLineDisplayClosedEventArgs
  public sealed class ClaimedMagneticStripeReader : IClosable {
    event TypedEventHandler&lt;ClaimedMagneticStripeReader, ClaimedMagneticStripeReaderClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedMagneticStripeReaderClosedEventArgs
  public sealed class ClaimedPosPrinter : IClosable {
    event TypedEventHandler&lt;ClaimedPosPrinter, ClaimedPosPrinterClosedEventArgs&gt; Closed;
  }
  public sealed class ClaimedPosPrinterClosedEventArgs
}
namespace Windows.Devices.PointOfService.Provider {
  public sealed class BarcodeScannerDisableScannerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerEnableScannerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerFrameReader : IClosable
  public sealed class BarcodeScannerFrameReaderFrameArrivedEventArgs
  public sealed class BarcodeScannerGetSymbologyAttributesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerHideVideoPreviewRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerProviderConnection : IClosable {
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync();
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync(BitmapPixelFormat preferredFormat);
    IAsyncOperation&lt;BarcodeScannerFrameReader&gt; CreateFrameReaderAsync(BitmapPixelFormat preferredFormat, BitmapSize preferredSize);
  }
  public sealed class BarcodeScannerSetActiveSymbologiesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
 public sealed class BarcodeScannerSetSymbologyAttributesRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerStartSoftwareTriggerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerStopSoftwareTriggerRequest {
    IAsyncAction ReportFailedAsync(int reason);
    IAsyncAction ReportFailedAsync(int reason, string failedReasonDescription);
  }
  public sealed class BarcodeScannerVideoFrame : IClosable
}
namespace Windows.Devices.Sensors {
  public sealed class HingeAngleReading
  public sealed class HingeAngleSensor
  public sealed class HingeAngleSensorReadingChangedEventArgs
  public sealed class SimpleOrientationSensor {
    public static IAsyncOperation&lt;SimpleOrientationSensor&gt; FromIdAsync(string deviceId);
    public static string GetDeviceSelector();
  }
}
namespace Windows.Devices.SmartCards {
  public static class KnownSmartCardAppletIds
  public sealed class SmartCardAppletIdGroup {
    string Description { get; set; }
    IRandomAccessStreamReference Logo { get; set; }
    ValueSet Properties { get; }
    bool SecureUserAuthenticationRequired { get; set; }
  }
  public sealed class SmartCardAppletIdGroupRegistration {
    string SmartCardReaderId { get; }
    IAsyncAction SetPropertiesAsync(ValueSet props);
  }
}
namespace Windows.Devices.WiFi {
  public enum WiFiPhyKind {
    HE = 10,
  }
}
namespace Windows.Foundation {
  public static class GuidHelper
}
namespace Windows.Globalization {
  public static class CurrencyIdentifiers {
    public static string MRU { get; }
    public static string SSP { get; }
    public static string STN { get; }
    public static string VES { get; }
  }
}
namespace Windows.Graphics.Capture {
  public sealed class Direct3D11CaptureFramePool : IClosable {
    public static Direct3D11CaptureFramePool CreateFreeThreaded(IDirect3DDevice device, DirectXPixelFormat pixelFormat, int numberOfBuffers, SizeInt32 size);
  }
  public sealed class GraphicsCaptureItem {
    public static GraphicsCaptureItem CreateFromVisual(Visual visual);
  }
}
namespace Windows.Graphics.Display.Core {
  public enum HdmiDisplayHdrOption {
    DolbyVisionLowLatency = 3,
  }
  public sealed class HdmiDisplayMode {
    bool IsDolbyVisionLowLatencySupported { get; }
  }
}
namespace Windows.Graphics.Holographic {
  public sealed class HolographicCamera {
    bool IsHardwareContentProtectionEnabled { get; set; }
    bool IsHardwareContentProtectionSupported { get; }
  }
  public sealed class HolographicQuadLayerUpdateParameters {
    bool CanAcquireWithHardwareProtection { get; }
    IDirect3DSurface AcquireBufferToUpdateContentWithHardwareProtection();
  }
}
namespace Windows.Graphics.Imaging {
  public sealed class BitmapDecoder : IBitmapFrame, IBitmapFrameWithSoftwareBitmap {
    public static Guid HeifDecoderId { get; }
    public static Guid WebpDecoderId { get; }
  }
  public sealed class BitmapEncoder {
    public static Guid HeifEncoderId { get; }
  }
}
namespace Windows.Management.Deployment {
  public enum DeploymentOptions : uint {
    ForceUpdateFromAnyVersion = (uint)262144,
  }
  public sealed class PackageManager {
    IAsyncOperationWithProgress&lt;DeploymentResult, DeploymentProgress&gt; DeprovisionPackageForAllUsersAsync(string packageFamilyName);
  }
  public enum RemovalOptions : uint {
    RemoveForAllUsers = (uint)524288,
  }
}
namespace Windows.Management.Policies {
  public static class NamedPolicy {
    public static IAsyncAction ClearAllPoliciesAsync();
    public static IAsyncAction ClearAllPoliciesAsync(string accountId);
    public static NamedPolicySetter TryCreatePolicySetter(string accountId);
    public static NamedPolicySetter TryCreatePolicySetterForUser(User user, string accountId);
  }
  public sealed class NamedPolicySetter
}
namespace Windows.Media.Audio {
  public sealed class CreateAudioDeviceInputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioDeviceOutputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioFileInputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioFileOutputNodeResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateAudioGraphResult {
    HResult ExtendedError { get; }
  }
  public sealed class CreateMediaSourceAudioInputNodeResult {
    HResult ExtendedError { get; }
  }
  public enum MixedRealitySpatialAudioFormatPolicy
  public sealed class SetDefaultSpatialAudioFormatResult
  public enum SetDefaultSpatialAudioFormatStatus
  public sealed class SpatialAudioDeviceConfiguration
  public sealed class SpatialAudioFormatConfiguration
  public static class SpatialAudioFormatSubtype
}
namespace Windows.Media.Control {
  public sealed class CurrentSessionChangedEventArgs
  public sealed class GlobalSystemMediaTransportControlsSession
  public sealed class GlobalSystemMediaTransportControlsSessionManager
  public sealed class GlobalSystemMediaTransportControlsSessionMediaProperties
  public sealed class GlobalSystemMediaTransportControlsSessionPlaybackControls
  public sealed class GlobalSystemMediaTransportControlsSessionPlaybackInfo
  public enum GlobalSystemMediaTransportControlsSessionPlaybackStatus
  public sealed class GlobalSystemMediaTransportControlsSessionTimelineProperties
 public sealed class MediaPropertiesChangedEventArgs
  public sealed class PlaybackInfoChangedEventArgs
  public sealed class SessionsChangedEventArgs
  public sealed class TimelinePropertiesChangedEventArgs
}
namespace Windows.Media.Core {
  public sealed class MediaStreamSample {
    IDirect3DSurface Direct3D11Surface { get; }
    public static MediaStreamSample CreateFromDirect3D11Surface(IDirect3DSurface surface, TimeSpan timestamp);
  }
}
namespace Windows.Media.Devices.Core {
  public sealed class CameraIntrinsics {
    public CameraIntrinsics(Vector2 focalLength, Vector2 principalPoint, Vector3 radialDistortion, Vector2 tangentialDistortion, uint imageWidth, uint imageHeight);
  }
}
namespace Windows.Media.Import {
  public enum PhotoImportContentTypeFilter {
    ImagesAndVideosFromCameraRoll = 3,
  }
  public sealed class PhotoImportItem {
    string Path { get; }
  }
}
namespace Windows.Media.MediaProperties {
  public sealed class ImageEncodingProperties : IMediaEncodingProperties {
    public static ImageEncodingProperties CreateHeif();
  }
  public static class MediaEncodingSubtypes {
    public static string Heif { get; }
  }
}
namespace Windows.Media.Protection.PlayReady {
  public static class PlayReadyStatics {
    public static IReference&lt;DateTime&gt; HardwareDRMDisabledAtTime { get; }
    public static IReference&lt;DateTime&gt; HardwareDRMDisabledUntilTime { get; }
    public static void ResetHardwareDRMDisabled();
  }
}
namespace Windows.Media.Streaming.Adaptive {
  public enum AdaptiveMediaSourceResourceType {
    MediaSegmentIndex = 5,
  }
}
namespace Windows.Networking.BackgroundTransfer {
  public enum BackgroundTransferPriority {
    Low = 2,
  }
}
namespace Windows.Networking.Connectivity {
  public sealed class ConnectionProfile {
    bool CanDelete { get; }
    IAsyncOperation&lt;ConnectionProfileDeleteStatus&gt; TryDeleteAsync();
  }
  public enum ConnectionProfileDeleteStatus
}
namespace Windows.Networking.NetworkOperators {
  public enum ESimOperationStatus {
    CardGeneralFailure = 13,
    ConfirmationCodeMissing = 14,
    EidMismatch = 18,
    InvalidMatchingId = 15,
    NoCorrespondingRequest = 23,
    NoEligibleProfileForThisDevice = 16,
    OperationAborted = 17,
    OperationProhibitedByProfileClass = 21,
    ProfileNotAvailableForNewBinding = 19,
    ProfileNotPresent = 22,
    ProfileNotReleasedByOperator = 20,
  }
}
namespace Windows.Perception {
  public sealed class PerceptionTimestamp {
    TimeSpan SystemRelativeTargetTime { get; }
  }
  public static class PerceptionTimestampHelper {
    public static PerceptionTimestamp FromSystemRelativeTargetTime(TimeSpan targetTime);
  }
}
namespace Windows.Perception.Spatial {
  public sealed class SpatialAnchorExporter
  public enum SpatialAnchorExportPurpose
  public sealed class SpatialAnchorExportSufficiency
  public sealed class SpatialLocation {
    Vector3 AbsoluteAngularAccelerationAxisAngle { get; }
    Vector3 AbsoluteAngularVelocityAxisAngle { get; }
  }
}
namespace Windows.Perception.Spatial.Preview {
  public static class SpatialGraphInteropPreview
}
namespace Windows.Security.DataProtection {
  public enum UserDataAvailability
  public sealed class UserDataAvailabilityStateChangedEventArgs
  public sealed class UserDataBufferUnprotectResult
  public enum UserDataBufferUnprotectStatus
  public sealed class UserDataProtectionManager
  public sealed class UserDataStorageItemProtectionInfo
  public enum UserDataStorageItemProtectionStatus
}
namespace Windows.Services.Cortana {
  public sealed class CortanaActionableInsights
  public sealed class CortanaActionableInsightsOptions
}
namespace Windows.Services.Store {
  public sealed class StoreAppLicense {
    bool IsDiscLicense { get; }
  }
  public sealed class StoreContext {
    IAsyncOperation&lt;StoreRateAndReviewResult&gt; RequestRateAndReviewAppAsync();
    IAsyncOperation&lt;IVectorView&lt;StoreQueueItem&gt;&gt; SetInstallOrderForAssociatedStoreQueueItemsAsync(IIterable&lt;StoreQueueItem&gt; items);
  }
  public sealed class StoreQueueItem {
    IAsyncAction CancelInstallAsync();
    IAsyncAction PauseInstallAsync();
    IAsyncAction ResumeInstallAsync();
  }
  public sealed class StoreRateAndReviewResult
  public enum StoreRateAndReviewStatus
}
namespace Windows.Storage.Provider {
  public enum StorageProviderHydrationPolicyModifier : uint {
    AutoDehydrationAllowed = (uint)4,
  }
  public sealed class StorageProviderSyncRootInfo {
    Guid ProviderId { get; set; }
  }
}
namespace Windows.System {
  public sealed class AppUriHandlerHost
  public sealed class AppUriHandlerRegistration
  public sealed class AppUriHandlerRegistrationManager
  public static class Launcher {
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathAsync(string path);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathAsync(string path, FolderLauncherOptions options);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathForUserAsync(User user, string path);
    public static IAsyncOperation&lt;bool&gt; LaunchFolderPathForUserAsync(User user, string path, FolderLauncherOptions options);
  }
}
namespace Windows.System.Preview {
  public enum HingeState
  public sealed class TwoPanelHingedDevicePosturePreview
  public sealed class TwoPanelHingedDevicePosturePreviewReading
  public sealed class TwoPanelHingedDevicePosturePreviewReadingChangedEventArgs
}
namespace Windows.System.Profile {
  public enum SystemOutOfBoxExperienceState
  public static class SystemSetupInfo
  public static class WindowsIntegrityPolicy
}
namespace Windows.System.Profile.SystemManufacturers {
  public sealed class SystemSupportDeviceInfo
  public static class SystemSupportInfo {
    public static SystemSupportDeviceInfo LocalDeviceInfo { get; }
  }
}
namespace Windows.System.RemoteSystems {
  public sealed class RemoteSystem {
    IVectorView&lt;RemoteSystemApp&gt; Apps { get; }
  }
  public sealed class RemoteSystemApp
  public sealed class RemoteSystemAppRegistration
  public sealed class RemoteSystemConnectionInfo
  public sealed class RemoteSystemConnectionRequest {
    RemoteSystemApp RemoteSystemApp { get; }
    public static RemoteSystemConnectionRequest CreateForApp(RemoteSystemApp remoteSystemApp);
  }
  public sealed class RemoteSystemWebAccountFilter : IRemoteSystemFilter
}
namespace Windows.System.Update {
  public enum SystemUpdateAttentionRequiredReason
  public sealed class SystemUpdateItem
  public enum SystemUpdateItemState
  public sealed class SystemUpdateLastErrorInfo
  public static class SystemUpdateManager
  public enum SystemUpdateManagerState
  public enum SystemUpdateStartInstallAction
}
namespace Windows.System.UserProfile {
  public sealed class AssignedAccessSettings
}
namespace Windows.UI.Accessibility {
  public sealed class ScreenReaderPositionChangedEventArgs
  public sealed class ScreenReaderService
}
namespace Windows.UI.Composition {
  public enum AnimationPropertyAccessMode
  public sealed class AnimationPropertyInfo : CompositionObject
  public sealed class BooleanKeyFrameAnimation : KeyFrameAnimation
  public class CompositionAnimation : CompositionObject, ICompositionAnimationBase {
    void SetExpressionReferenceParameter(string parameterName, IAnimationObject source);
  }
  public enum CompositionBatchTypes : uint {
    AllAnimations = (uint)5,
    InfiniteAnimation = (uint)4,
  }
  public sealed class CompositionGeometricClip : CompositionClip
  public class CompositionGradientBrush : CompositionBrush {
    CompositionMappingMode MappingMode { get; set; }
  }
  public enum CompositionMappingMode
  public class CompositionObject : IAnimationObject, IClosable {
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    public static void StartAnimationGroupWithIAnimationObject(IAnimationObject target, ICompositionAnimationBase animation);
    public static void StartAnimationWithIAnimationObject(IAnimationObject target, string propertyName, CompositionAnimation animation);
  }
  public sealed class Compositor : IClosable {
    BooleanKeyFrameAnimation CreateBooleanKeyFrameAnimation();
    CompositionGeometricClip CreateGeometricClip();
    CompositionGeometricClip CreateGeometricClip(CompositionGeometry geometry);
    RedirectVisual CreateRedirectVisual();
    RedirectVisual CreateRedirectVisual(Visual source);
  }
  public interface IAnimationObject
  public sealed class RedirectVisual : ContainerVisual
}
namespace Windows.UI.Composition.Interactions {
  public sealed class InteractionSourceConfiguration : CompositionObject
  public enum InteractionSourceRedirectionMode
  public sealed class InteractionTracker : CompositionObject {
    bool IsInertiaFromImpulse { get; }
    int TryUpdatePosition(Vector3 value, InteractionTrackerClampingOption option);
    int TryUpdatePositionBy(Vector3 amount, InteractionTrackerClampingOption option);
  }
  public enum InteractionTrackerClampingOption
  public sealed class InteractionTrackerInertiaStateEnteredArgs {
    bool IsInertiaFromImpulse { get; }
  }
  public class VisualInteractionSource : CompositionObject, ICompositionInteractionSource {
    InteractionSourceConfiguration PointerWheelConfig { get; }
  }
}
namespace Windows.UI.Input.Inking {
  public enum HandwritingLineHeight
  public sealed class PenAndInkSettings
  public enum PenHandedness
}
namespace Windows.UI.Input.Inking.Preview {
  public sealed class PalmRejectionDelayZonePreview : IClosable
}
namespace Windows.UI.Notifications {
  public sealed class ScheduledToastNotificationShowingEventArgs
  public sealed class ToastNotifier {
    event TypedEventHandler&lt;ToastNotifier, ScheduledToastNotificationShowingEventArgs&gt; ScheduledToastNotificationShowing;
  }
}
namespace Windows.UI.Shell {
  public enum SecurityAppKind
  public sealed class SecurityAppManager
  public struct SecurityAppManagerContract
  public enum SecurityAppState
  public enum SecurityAppSubstatus
  public sealed class TaskbarManager {
    IAsyncOperation&lt;bool&gt; IsSecondaryTilePinnedAsync(string tileId);
    IAsyncOperation&lt;bool&gt; RequestPinSecondaryTileAsync(SecondaryTile secondaryTile);
    IAsyncOperation&lt;bool&gt; TryUnpinSecondaryTileAsync(string tileId);
  }
}
namespace Windows.UI.StartScreen {
  public sealed class StartScreenManager {
    IAsyncOperation&lt;bool&gt; ContainsSecondaryTileAsync(string tileId);
    IAsyncOperation&lt;bool&gt; TryRemoveSecondaryTileAsync(string tileId);
  }
}
namespace Windows.UI.Text {
  public sealed class RichEditTextDocument : ITextDocument {
    void ClearUndoRedoHistory();
  }
}
namespace Windows.UI.Text.Core {
  public sealed class CoreTextLayoutRequest {
    CoreTextLayoutBounds LayoutBoundsVisualPixels { get; }
  }
}
namespace Windows.UI.ViewManagement {
  public enum ApplicationViewWindowingMode {
    CompactOverlay = 3,
    Maximized = 4,
  }
}
namespace Windows.UI.ViewManagement.Core {
  public sealed class CoreInputView {
    bool TryHide();
    bool TryShow();
    bool TryShow(CoreInputViewKind type);
  }
  public enum CoreInputViewKind
}
namespace Windows.UI.WebUI {
  public sealed class BackgroundActivatedEventArgs : IBackgroundActivatedEventArgs
  public delegate void BackgroundActivatedEventHandler(object sender, IBackgroundActivatedEventArgs eventArgs);
  public sealed class NewWebUIViewCreatedEventArgs
  public static class WebUIApplication {
    public static event BackgroundActivatedEventHandler BackgroundActivated;
    public static event EventHandler&lt;NewWebUIViewCreatedEventArgs&gt; NewWebUIViewCreated;
  }
  public sealed class WebUIView : IWebViewControl, IWebViewControl2
}
namespace Windows.UI.Xaml {
  public class BrushTransition
  public class ColorPaletteResources : ResourceDictionary
  public class DataTemplate : FrameworkTemplate, IElementFactory {
    UIElement GetElement(ElementFactoryGetArgs args);
    void RecycleElement(ElementFactoryRecycleArgs args);
  }
  public sealed class DebugSettings {
    bool FailFastOnErrors { get; set; }
  }
  public sealed class EffectiveViewportChangedEventArgs
  public class ElementFactoryGetArgs
  public class ElementFactoryRecycleArgs
  public class FrameworkElement : UIElement {
    bool IsLoaded { get; }
    event TypedEventHandler&lt;FrameworkElement, EffectiveViewportChangedEventArgs&gt; EffectiveViewportChanged;
    void InvalidateViewport();
  }
  public interface IElementFactory
  public class ScalarTransition
  public class UIElement : DependencyObject, IAnimationObject {
    bool CanBeScrollAnchor { get; set; }
    public static DependencyProperty CanBeScrollAnchorProperty { get; }
    Vector3 CenterPoint { get; set; }
    ScalarTransition OpacityTransition { get; set; }
    float Rotation { get; set; }
    Vector3 RotationAxis { get; set; }
    ScalarTransition RotationTransition { get; set; }
    Vector3 Scale { get; set; }
    Vector3Transition ScaleTransition { get; set; }
    Shadow Shadow { get; set; }
    public static DependencyProperty ShadowProperty { get; }
    Matrix4x4 TransformMatrix { get; set; }
    Vector3 Translation { get; set; }
    Vector3Transition TranslationTransition { get; set; }
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    virtual void PopulatePropertyInfoOverride(string propertyName, AnimationPropertyInfo animationPropertyInfo);
    void StartAnimation(ICompositionAnimationBase animation);
    void StopAnimation(ICompositionAnimationBase animation);
  }
 public class UIElementWeakCollection : IIterable&lt;UIElement&gt;, IVector&lt;UIElement&gt;
  public class Vector3Transition
  public enum Vector3TransitionComponents : uint
}
namespace Windows.UI.Xaml.Automation {
  public sealed class AutomationElementIdentifiers {
    public static AutomationProperty IsDialogProperty { get; }
  }
  public sealed class AutomationProperties {
    public static DependencyProperty IsDialogProperty { get; }
    public static bool GetIsDialog(DependencyObject element);
    public static void SetIsDialog(DependencyObject element, bool value);
  }
}
namespace Windows.UI.Xaml.Automation.Peers {
  public class AppBarButtonAutomationPeer : ButtonAutomationPeer, IExpandCollapseProvider {
    ExpandCollapseState ExpandCollapseState { get; }
    void Collapse();
    void Expand();
  }
  public class AutomationPeer : DependencyObject {
    bool IsDialog();
    virtual bool IsDialogCore();
  }
  public class MenuBarAutomationPeer : FrameworkElementAutomationPeer
  public class MenuBarItemAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IInvokeProvider
}
namespace Windows.UI.Xaml.Controls {
  public sealed class AnchorRequestedEventArgs
  public class AppBarElementContainer : ContentControl, ICommandBarElement, ICommandBarElement2
  public sealed class AutoSuggestBox : ItemsControl {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
  }
  public enum BackgroundSizing
  public sealed class Border : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    BrushTransition BackgroundTransition { get; set; }
  }
  public class CalendarDatePicker : Control {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
  }
  public class ComboBox : Selector {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    bool IsEditable { get; set; }
    public static DependencyProperty IsEditableProperty { get; }
    string Text { get; set; }
    Style TextBoxStyle { get; set; }
    public static DependencyProperty TextBoxStyleProperty { get; }
    public static DependencyProperty TextProperty { get; }
    event TypedEventHandler&lt;ComboBox, ComboBoxTextSubmittedEventArgs&gt; TextSubmitted;
  }
  public sealed class ComboBoxTextSubmittedEventArgs
  public class CommandBarFlyout : FlyoutBase
  public class ContentPresenter : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    BrushTransition BackgroundTransition { get; set; }
  }
  public class Control : FrameworkElement {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
    CornerRadius CornerRadius { get; set; }
    public static DependencyProperty CornerRadiusProperty { get; }
  }
  public class DataTemplateSelector : IElementFactory {
    UIElement GetElement(ElementFactoryGetArgs args);
    void RecycleElement(ElementFactoryRecycleArgs args);
  }
  public class DatePicker : Control {
    IReference&lt;DateTime&gt; SelectedDate { get; set; }
    public static DependencyProperty SelectedDateProperty { get; }
    event TypedEventHandler&lt;DatePicker, DatePickerSelectedValueChangedEventArgs&gt; SelectedDateChanged;
  }
  public sealed class DatePickerSelectedValueChangedEventArgs
  public class DropDownButton : Button
  public class DropDownButtonAutomationPeer : ButtonAutomationPeer, IExpandCollapseProvider
  public class Frame : ContentControl, INavigate {
    bool IsNavigationStackEnabled { get; set; }
    public static DependencyProperty IsNavigationStackEnabledProperty { get; }
    bool NavigateToType(TypeName sourcePageType, object parameter, FrameNavigationOptions navigationOptions);
  }
  public class Grid : Panel {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public class IconSourceElement : IconElement
  public sealed class InputPropertyAttribute : Attribute
  public interface IScrollAnchorProvider
  public class MenuBar : Control
  public class MenuBarItem : Control
  public class MenuBarItemFlyout : MenuFlyout
  public class NavigationView : ContentControl {
    UIElement ContentOverlay { get; set; }
    public static DependencyProperty ContentOverlayProperty { get; }
    bool IsPaneVisible { get; set; }
    public static DependencyProperty IsPaneVisibleProperty { get; }
    NavigationViewOverflowLabelMode OverflowLabelMode { get; set; }
    public static DependencyProperty OverflowLabelModeProperty { get; }
    UIElement PaneCustomContent { get; set; }
    public static DependencyProperty PaneCustomContentProperty { get; }
    NavigationViewPaneDisplayMode PaneDisplayMode { get; set; }
    public static DependencyProperty PaneDisplayModeProperty { get; }
    UIElement PaneHeader { get; set; }
    public static DependencyProperty PaneHeaderProperty { get; }
    NavigationViewSelectionFollowsFocus SelectionFollowsFocus { get; set; }
    public static DependencyProperty SelectionFollowsFocusProperty { get; }
    NavigationViewShoulderNavigationEnabled ShoulderNavigationEnabled { get; set; }
    public static DependencyProperty ShoulderNavigationEnabledProperty { get; }
    NavigationViewTemplateSettings TemplateSettings { get; }
    public static DependencyProperty TemplateSettingsProperty { get; }
  }
  public class NavigationViewItem : NavigationViewItemBase {
    bool SelectsOnInvoked { get; set; }
    public static DependencyProperty SelectsOnInvokedProperty { get; }
  }
  public sealed class NavigationViewItemInvokedEventArgs {
    NavigationViewItemBase InvokedItemContainer { get; }
    NavigationTransitionInfo RecommendedNavigationTransitionInfo { get; }
  }
  public enum NavigationViewOverflowLabelMode
  public enum NavigationViewPaneDisplayMode
  public sealed class NavigationViewSelectionChangedEventArgs {
    NavigationTransitionInfo RecommendedNavigationTransitionInfo { get; }
    NavigationViewItemBase SelectedItemContainer { get; }
  }
  public enum NavigationViewSelectionFollowsFocus
  public enum NavigationViewShoulderNavigationEnabled
  public class NavigationViewTemplateSettings : DependencyObject
  public class Panel : FrameworkElement {
    BrushTransition BackgroundTransition { get; set; }
  }
  public sealed class PasswordBox : Control {
    bool CanPasteClipboardContent { get; }
    public static DependencyProperty CanPasteClipboardContentProperty { get; }
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void PasteFromClipboard();
  }
  public class RelativePanel : Panel {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public class RichEditBox : Control {
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase ProofingMenuFlyout { get; }
    public static DependencyProperty ProofingMenuFlyoutProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    RichEditTextDocument TextDocument { get; }
    event TypedEventHandler&lt;RichEditBox, RichEditBoxSelectionChangingEventArgs&gt; SelectionChanging;
  }
  public sealed class RichEditBoxSelectionChangingEventArgs
  public sealed class RichTextBlock : FrameworkElement {
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void CopySelectionToClipboard();
  }
  public sealed class ScrollContentPresenter : ContentPresenter {
    bool CanContentRenderOutsideBounds { get; set; }
    public static DependencyProperty CanContentRenderOutsideBoundsProperty { get; }
    bool SizesContentToTemplatedParent { get; set; }
    public static DependencyProperty SizesContentToTemplatedParentProperty { get; }
  }
  public sealed class ScrollViewer : ContentControl, IScrollAnchorProvider {
    bool CanContentRenderOutsideBounds { get; set; }
    public static DependencyProperty CanContentRenderOutsideBoundsProperty { get; }
    UIElement CurrentAnchor { get; }
    double HorizontalAnchorRatio { get; set; }
    public static DependencyProperty HorizontalAnchorRatioProperty { get; }
    bool ReduceViewportForCoreInputViewOcclusions { get; set; }
    public static DependencyProperty ReduceViewportForCoreInputViewOcclusionsProperty { get; }
    double VerticalAnchorRatio { get; set; }
    public static DependencyProperty VerticalAnchorRatioProperty { get; }
    event TypedEventHandler&lt;ScrollViewer, AnchorRequestedEventArgs&gt; AnchorRequested;
    public static bool GetCanContentRenderOutsideBounds(DependencyObject element);
    void RegisterAnchorCandidate(UIElement element);
    public static void SetCanContentRenderOutsideBounds(DependencyObject element, bool canContentRenderOutsideBounds);
    void UnregisterAnchorCandidate(UIElement element);
  }
  public class SplitButton : ContentControl
  public class SplitButtonAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IInvokeProvider
  public sealed class SplitButtonClickEventArgs
  public class StackPanel : Panel, IInsertionPanel, IScrollSnapPointsInfo {
    BackgroundSizing BackgroundSizing { get; set; }
    public static DependencyProperty BackgroundSizingProperty { get; }
  }
  public sealed class TextBlock : FrameworkElement {
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    void CopySelectionToClipboard();
  }
  public class TextBox : Control {
    bool CanPasteClipboardContent { get; }
    public static DependencyProperty CanPasteClipboardContentProperty { get; }
    bool CanRedo { get; }
    public static DependencyProperty CanRedoProperty { get; }
    bool CanUndo { get; }
    public static DependencyProperty CanUndoProperty { get; }
    object Description { get; set; }
    public static DependencyProperty DescriptionProperty { get; }
    FlyoutBase ProofingMenuFlyout { get; }
    public static DependencyProperty ProofingMenuFlyoutProperty { get; }
    FlyoutBase SelectionFlyout { get; set; }
    public static DependencyProperty SelectionFlyoutProperty { get; }
    event TypedEventHandler&lt;TextBox, TextBoxSelectionChangingEventArgs&gt; SelectionChanging;
    void ClearUndoRedoHistory();
    void CopySelectionToClipboard();
    void CutSelectionToClipboard();
    void PasteFromClipboard();
    void Redo();
    void Undo();
  }
  public sealed class TextBoxSelectionChangingEventArgs
  public class TextCommandBarFlyout : CommandBarFlyout
  public class TimePicker : Control {
    IReference&lt;TimeSpan&gt; SelectedTime { get; set; }
    public static DependencyProperty SelectedTimeProperty { get; }
    event TypedEventHandler&lt;TimePicker, TimePickerSelectedValueChangedEventArgs&gt; SelectedTimeChanged;
  }
  public sealed class TimePickerSelectedValueChangedEventArgs
  public class ToggleSplitButton : SplitButton
  public class ToggleSplitButtonAutomationPeer : FrameworkElementAutomationPeer, IExpandCollapseProvider, IToggleProvider
  public sealed class ToggleSplitButtonIsCheckedChangedEventArgs
  public class ToolTip : ContentControl {
    IReference&lt;Rect&gt; PlacementRect { get; set; }
    public static DependencyProperty PlacementRectProperty { get; }
  }
  public class TreeView : Control {
    bool CanDragItems { get; set; }
    public static DependencyProperty CanDragItemsProperty { get; }
    bool CanReorderItems { get; set; }
    public static DependencyProperty CanReorderItemsProperty { get; }
    Style ItemContainerStyle { get; set; }
    public static DependencyProperty ItemContainerStyleProperty { get; }
    StyleSelector ItemContainerStyleSelector { get; set; }
    public static DependencyProperty ItemContainerStyleSelectorProperty { get; }
    TransitionCollection ItemContainerTransitions { get; set; }
    public static DependencyProperty ItemContainerTransitionsProperty { get; }
    object ItemsSource { get; set; }
    public static DependencyProperty ItemsSourceProperty { get; }
    DataTemplate ItemTemplate { get; set; }
    public static DependencyProperty ItemTemplateProperty { get; }
    DataTemplateSelector ItemTemplateSelector { get; set; }
    public static DependencyProperty ItemTemplateSelectorProperty { get; }
    event TypedEventHandler&lt;TreeView, TreeViewDragItemsCompletedEventArgs&gt; DragItemsCompleted;
    event TypedEventHandler&lt;TreeView, TreeViewDragItemsStartingEventArgs&gt; DragItemsStarting;
    DependencyObject ContainerFromItem(object item);
    DependencyObject ContainerFromNode(TreeViewNode node);
    object ItemFromContainer(DependencyObject container);
    TreeViewNode NodeFromContainer(DependencyObject container);
  }
  public sealed class TreeViewCollapsedEventArgs {
    object Item { get; }
  }
  public sealed class TreeViewDragItemsCompletedEventArgs
  public sealed class TreeViewDragItemsStartingEventArgs
  public sealed class TreeViewExpandingEventArgs {
    object Item { get; }
  }
  public class TreeViewItem : ListViewItem {
    bool HasUnrealizedChildren { get; set; }
    public static DependencyProperty HasUnrealizedChildrenProperty { get; }
    object ItemsSource { get; set; }
    public static DependencyProperty ItemsSourceProperty { get; }
  }
  public class TwoPaneView : Control
  public enum TwoPaneViewMode
  public enum TwoPaneViewPriority
  public enum TwoPaneViewTallModeConfiguration
  public enum TwoPaneViewWideModeConfiguration
  public sealed class WebView : FrameworkElement {
    event TypedEventHandler&lt;WebView, WebViewWebResourceRequestedEventArgs&gt; WebResourceRequested;
  }
  public sealed class WebViewWebResourceRequestedEventArgs
}
namespace Windows.UI.Xaml.Controls.Maps {
  public enum MapTileAnimationState
  public sealed class MapTileBitmapRequestedEventArgs {
    int FrameIndex { get; }
  }
  public class MapTileSource : DependencyObject {
    MapTileAnimationState AnimationState { get; }
    public static DependencyProperty AnimationStateProperty { get; }
    bool AutoPlay { get; set; }
    public static DependencyProperty AutoPlayProperty { get; }
    int FrameCount { get; set; }
    public static DependencyProperty FrameCountProperty { get; }
    TimeSpan FrameDuration { get; set; }
    public static DependencyProperty FrameDurationProperty { get; }
    void Pause();
    void Play();
    void Stop();
  }
  public sealed class MapTileUriRequestedEventArgs {
    int FrameIndex { get; }
  }
}
namespace Windows.UI.Xaml.Controls.Primitives {
  public class CommandBarFlyoutCommandBar : CommandBar
  public sealed class CommandBarFlyoutCommandBarTemplateSettings : DependencyObject
  public class FlyoutBase : DependencyObject {
    bool AreOpenCloseAnimationsEnabled { get; set; }
    public static DependencyProperty AreOpenCloseAnimationsEnabledProperty { get; }
    bool InputDevicePrefersPrimaryCommands { get; }
    public static DependencyProperty InputDevicePrefersPrimaryCommandsProperty { get; }
    bool IsOpen { get; }
    public static DependencyProperty IsOpenProperty { get; }
    FlyoutShowMode ShowMode { get; set; }
    public static DependencyProperty ShowModeProperty { get; }
    public static DependencyProperty TargetProperty { get; }
    void ShowAt(DependencyObject placementTarget, FlyoutShowOptions showOptions);
  }
  public enum FlyoutPlacementMode {
    Auto = 13,
    BottomEdgeAlignedLeft = 7,
    BottomEdgeAlignedRight = 8,
    LeftEdgeAlignedBottom = 10,
    LeftEdgeAlignedTop = 9,
    RightEdgeAlignedBottom = 12,
    RightEdgeAlignedTop = 11,
    TopEdgeAlignedLeft = 5,
    TopEdgeAlignedRight = 6,
  }
  public enum FlyoutShowMode
  public class FlyoutShowOptions
  public class NavigationViewItemPresenter : ContentControl
}
namespace Windows.UI.Xaml.Core.Direct {
  public interface IXamlDirectObject
  public sealed class XamlDirect
  public struct XamlDirectContract
  public enum XamlEventIndex
  public enum XamlPropertyIndex
  public enum XamlTypeIndex
}
namespace Windows.UI.Xaml.Hosting {
  public class DesktopWindowXamlSource : IClosable
  public sealed class DesktopWindowXamlSourceGotFocusEventArgs
  public sealed class DesktopWindowXamlSourceTakeFocusRequestedEventArgs
  public sealed class WindowsXamlManager : IClosable
  public enum XamlSourceFocusNavigationReason
  public sealed class XamlSourceFocusNavigationRequest
  public sealed class XamlSourceFocusNavigationResult
}
namespace Windows.UI.Xaml.Input {
  public sealed class CanExecuteRequestedEventArgs
  public sealed class ExecuteRequestedEventArgs
  public sealed class FocusManager {
    public static event EventHandler&lt;GettingFocusEventArgs&gt; GettingFocus;
    public static event EventHandler&lt;FocusManagerGotFocusEventArgs&gt; GotFocus;
    public static event EventHandler&lt;LosingFocusEventArgs&gt; LosingFocus;
    public static event EventHandler&lt;FocusManagerLostFocusEventArgs&gt; LostFocus;
  }
  public sealed class FocusManagerGotFocusEventArgs
  public sealed class FocusManagerLostFocusEventArgs
  public sealed class GettingFocusEventArgs : RoutedEventArgs {
    Guid CorrelationId { get; }
  }
  public sealed class LosingFocusEventArgs : RoutedEventArgs {
    Guid CorrelationId { get; }
  }
  public class StandardUICommand : XamlUICommand
  public enum StandardUICommandKind
  public class XamlUICommand : DependencyObject, ICommand
}
namespace Windows.UI.Xaml.Markup {
  public sealed class FullXamlMetadataProviderAttribute : Attribute
  public interface IXamlBindScopeDiagnostics
  public interface IXamlType2 : IXamlType
}
namespace Windows.UI.Xaml.Media {
  public class Brush : DependencyObject, IAnimationObject {
    void PopulatePropertyInfo(string propertyName, AnimationPropertyInfo propertyInfo);
    virtual void PopulatePropertyInfoOverride(string propertyName, AnimationPropertyInfo animationPropertyInfo);
  }
  public class Shadow : DependencyObject
  public class ThemeShadow : Shadow
}
namespace Windows.UI.Xaml.Media.Animation {
  public class BasicConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public sealed class ConnectedAnimation {
    ConnectedAnimationConfiguration Configuration { get; set; }
  }
  public class ConnectedAnimationConfiguration
  public class DirectConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public class GravityConnectedAnimationConfiguration : ConnectedAnimationConfiguration
  public enum SlideNavigationTransitionEffect
  public sealed class SlideNavigationTransitionInfo : NavigationTransitionInfo {
    SlideNavigationTransitionEffect Effect { get; set; }
    public static DependencyProperty EffectProperty { get; }
  }
}
namespace Windows.UI.Xaml.Navigation {
  public class FrameNavigationOptions
}
namespace Windows.Web.UI {
  public interface IWebViewControl2
  public sealed class WebViewControlNewWindowRequestedEventArgs {
    IWebViewControl NewWindow { get; set; }
    Deferral GetDeferral();
  }
  public enum WebViewControlPermissionType {
    ImmersiveView = 6,
  }
}
namespace Windows.Web.UI.Interop {
  public sealed class WebViewControl : IWebViewControl, IWebViewControl2 {
    event TypedEventHandler&lt;WebViewControl, object&gt; GotFocus;
    event TypedEventHandler&lt;WebViewControl, object&gt; LostFocus;
    void AddInitializeScript(string script);
  }
}  

</pre>
<h2>Removals:</h2>
<pre class="brush: plain; title: ; notranslate">

namespace Windows.Gaming.UI {
  public sealed class GameMonitor
  public enum GameMonitoringPermission
}

</pre>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/07/31/windows-10-sdk-preview-build-17723-available-now/">Windows 10 SDK Preview Build 17723 available now!</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></content:encoded>
			<wfw:commentRss>https://blogs.windows.com/buildingapps/2018/07/31/windows-10-sdk-preview-build-17723-available-now/feed/</wfw:commentRss>
		<slash:comments>1</slash:comments>
		</item>
		<item>
		<title>Top 4 ways to optimize your Microsoft Store listing</title>
		<link>https://blogs.windows.com/buildingapps/2018/07/25/top-4-ways-to-optimize-your-microsoft-store-listing/</link>
		<comments>https://blogs.windows.com/buildingapps/2018/07/25/top-4-ways-to-optimize-your-microsoft-store-listing/#respond</comments>
		<pubDate>Wed, 25 Jul 2018 17:00:30 +0000</pubDate>
		<dc:creator><![CDATA[Microsoft Store Team]]></dc:creator>
				<category><![CDATA[PC]]></category>
		<category><![CDATA[Apps]]></category>
		<category><![CDATA[microsoft store]]></category>
		<category><![CDATA[Xbox]]></category>

		<guid isPermaLink="false">http://blogs.windows.com/buildingapps/?p=53853</guid>
		<description><![CDATA[<p>When publishing your app to the Microsoft Store, be sure to take advantage of the many options to make your Store listing stand out. Great video, text, and images can help create customer interest and drive purchases. Remember, your Microsoft Store listing will be many customers’ first exposure to your app. It’s crucial to make [&#8230;]</p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/07/25/top-4-ways-to-optimize-your-microsoft-store-listing/">Top 4 ways to optimize your Microsoft Store listing</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></description>
				<content:encoded><![CDATA[<p>When publishing your app to the Microsoft Store, be sure to take advantage of the many options to make your Store listing stand out. Great video, text, and images can help create customer interest and drive purchases. Remember, your Microsoft Store listing will be many customers’ first exposure to your app. It’s crucial to make a good first impression!</p>
<h2><strong>Make the most of your listing</strong></h2>
<h3><strong>1. Include video trailers</strong></h3>
<p><img class="aligncenter size-full wp-image-53859" src="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/07/d2af741b04756da5b2460317741bd247.png" alt="Affinity Designer Microsoft Store Listing" width="974" height="502" srcset="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/07/d2af741b04756da5b2460317741bd247.png 974w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/07/d2af741b04756da5b2460317741bd247-300x155.png 300w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/07/d2af741b04756da5b2460317741bd247-768x396.png 768w" sizes="(max-width: 974px) 100vw, 974px" /></p>
<p>Video trailers are short videos that spotlight your product and give your customers a quick look at what it does. On average, including one or more video trailers can increase downloads<strong><em> by up to 11%</em></strong>.</p>
<p><a href="https://www.microsoft.com/en-us/p/affinity-designer/9nblggh35lrm?activetab=pivot%3Aoverviewtab">Check out Affinity Designer’s trailer</a> for an example that really shows off what the app can do.</p>
<p><strong>Quick trailer tips:</strong></p>
<ul>
<li>Focus on high quality and short length (60 seconds or less).</li>
<li>Use different thumbnails for each trailer.</li>
<li>Keep key messaging short and centered in each frame.</li>
<li>When using trailers, you must also provide a <strong>1920 x 1080 pixel image (16:9) in the Promotional images section</strong> in order for your trailers to appear at the top of your Store listing. This image will appear after your trailers have finished playing.</li>
</ul>
<p>Note that trailers are only shown to customers on Windows 10, version 1607 or later (which includes Xbox).</p>
<p>See more information and tips <a href="https://docs.microsoft.com/en-us/windows/uwp/publish/app-screenshots-and-images#trailers">here</a>.</p>
<h3><strong>2. Create a great app description</strong></h3>
<p>The description is the first thing your customer reads about your app in the Microsoft Store, and it may also appear in search results and algorithm lists—so make it count.</p>
<p><strong>Quick description tips:</strong></p>
<ul>
<li>Start with the value prop: Why should your customer buy this?</li>
<li>Focus on your app’s appeal with plain, clear language.</li>
<li>Localize for all your markets.</li>
</ul>
<p>Read more <a href="https://docs.microsoft.com/en-us/windows/uwp/publish/write-a-great-app-description">here.</a></p>
<h3><strong style="font-size: 1.1875rem">3. Include an eye-catching logo</strong></h3>
<p><img class="aligncenter size-full wp-image-53862" src="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/07/c33b053f8aae5bc94364380817907e1a.png" alt="AUTODESK Sketchbook logo in Microsoft Store." width="249" height="375" srcset="https://blogs.windows.com/uploads/mswbprod/sites/3/2018/07/c33b053f8aae5bc94364380817907e1a.png 249w, https://blogs.windows.com/uploads/mswbprod/sites/3/2018/07/c33b053f8aae5bc94364380817907e1a-199x300.png 199w" sizes="(max-width: 249px) 100vw, 249px" /></p>
<p>Your logo is the main image displayed on Windows 10 and Xbox, and in searches or collections and we strongly recommend providing both a 9:16 poster art and 1:1 box art image. A good logo can visually “pop” and lead customers to see more.</p>
<p>We recommend providing these logo images to create an optimal appearance in the Store. In particular, the <strong>9:16 Poster art</strong> image is required for proper display for customers on Windows 10 and Xbox devices. You also have the option to <a href="https://docs.microsoft.com/en-us/windows/uwp/publish/app-screenshots-and-images#display-only-uploaded-logo-images-in-the-store">upload additional logo images that will be used in the Store</a> (instead of images taken from your app’s packages) to create a more customized display.</p>
<p><strong>Quick logo tips:</strong></p>
<ul>
<li>Include your app name as a key part of the image.</li>
<li>Provide .png files no larger than 50MB each.</li>
<li>Provide all requested formats and sizes for optimal display across devices.</li>
</ul>
<p>More details on all the display options <a href="https://docs.microsoft.com/en-us/windows/uwp/publish/app-screenshots-and-images#store-logos">here.</a></p>
<h3><strong style="font-size: 1.1875rem">4. Keep your customers up to date</strong></h3>
<p>When you update your app it’s always a good idea to let customers know what you’ve improved in the latest release, especially if you’ve fixed bugs or improved the app based on customer feedback. Use the <strong>What’s new in this version</strong> text box to share that information with your customers.  In addition to letting your current customers know what’s changed, this also shows potential new customers that you’re listening to feedback and continuing to add new features.<strong> </strong></p>
<h2><strong>Get started now</strong></h2>
<p>Whether you’re submitting your app for the first time or making an update to an app that’s in the Store, we hope you’ll find these tips useful. For more details on all of these options, along with other ways you can create great Microsoft Store listings, start <a href="https://docs.microsoft.com/en-us/windows/uwp/publish/create-app-store-listings">here.</a></p>
<p>The post <a rel="nofollow" href="https://blogs.windows.com/buildingapps/2018/07/25/top-4-ways-to-optimize-your-microsoft-store-listing/">Top 4 ways to optimize your Microsoft Store listing</a> appeared first on <a rel="nofollow" href="https://blogs.windows.com/buildingapps">Windows Developer Blog</a>.</p>
]]></content:encoded>
			<wfw:commentRss>https://blogs.windows.com/buildingapps/2018/07/25/top-4-ways-to-optimize-your-microsoft-store-listing/feed/</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>